{"version":3,"file":"segmentCollection.js","names":["ONE_SECOND","LifeCycleEventType","isPageExitReason","setTimeout","clearTimeout","buildReplayPayload","Segment","SEGMENT_DURATION_LIMIT","SEGMENT_BYTES_LIMIT","startSegmentCollection","lifeCycle","configuration","sessionManager","viewContexts","httpRequest","encoder","doStartSegmentCollection","computeSegmentContext","SegmentCollectionStatus","WaitingForInitialRecord","SegmentPending","Stopped","getSegmentContext","state","status","nextSegmentCreationReason","subscribeViewCreated","subscribe","VIEW_CREATED","flushSegment","unsubscribeViewCreated","unsubscribe","subscribePageExited","PAGE_EXITED","pageExitEvent","reason","unsubscribePageExited","flushReason","segment","flush","metadata","payload","getEncodedBytes","getRawBytesCount","sendOnExit","send","expirationTimeoutId","addRecord","record","context","getEncodedBytesCount","stop","session","findTrackedSession","viewContext","findView","undefined","sdk","name","sdkName","version","sdkVersion","env","service","app","id","applicationId","view","setSegmentBytesLimit","newSegmentBytesLimit","arguments","length"],"sources":["../../../../src/domain/replay/segmentCollection/segmentCollection.js"],"sourcesContent":["import {\n  ONE_SECOND,\n  LifeCycleEventType,\n  isPageExitReason,\n  setTimeout,\n  clearTimeout\n} from '@cloudcare/browser-core'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport { Segment } from './segment'\n\nexport var SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport var SEGMENT_BYTES_LIMIT = 60000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle,\n  configuration,\n  sessionManager,\n  viewContexts,\n  httpRequest,\n  encoder\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    function () {\n      return computeSegmentContext(configuration, sessionManager, viewContexts)\n    },\n    httpRequest,\n    encoder\n  )\n}\n\nvar SegmentCollectionStatus = {\n  WaitingForInitialRecord: 0,\n  SegmentPending: 1,\n  Stopped: 2\n}\n\nexport function doStartSegmentCollection(\n  lifeCycle,\n  getSegmentContext,\n  httpRequest,\n  encoder\n) {\n  var state = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init'\n  }\n  var subscribeViewCreated = lifeCycle.subscribe(\n    LifeCycleEventType.VIEW_CREATED,\n    function () {\n      flushSegment('view_change')\n    }\n  )\n  var unsubscribeViewCreated = subscribeViewCreated.unsubscribe\n  var subscribePageExited = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    function (pageExitEvent) {\n      flushSegment(pageExitEvent.reason)\n    }\n  )\n  var unsubscribePageExited = subscribePageExited.unsubscribe\n\n  function flushSegment(flushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush(function (metadata) {\n        var payload = buildReplayPayload(\n          encoder.getEncodedBytes(),\n          metadata,\n          encoder.getRawBytesCount()\n        )\n\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      })\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped\n      }\n    }\n  }\n\n  return {\n    addRecord: function (record) {\n      if (state.status === SegmentCollectionStatus.Stopped) {\n        return\n      }\n\n      if (state.status === SegmentCollectionStatus.WaitingForInitialRecord) {\n        var context = getSegmentContext()\n        if (!context) {\n          return\n        }\n\n        state = {\n          status: SegmentCollectionStatus.SegmentPending,\n          segment: new Segment(\n            encoder,\n            context,\n            state.nextSegmentCreationReason\n          ),\n          expirationTimeoutId: setTimeout(function () {\n            flushSegment('segment_duration_limit')\n          }, SEGMENT_DURATION_LIMIT)\n        }\n      }\n\n      var segment = state.segment\n\n      segment.addRecord(record, function () {\n        if (\n          // the written segment is still pending\n          state.status === SegmentCollectionStatus.SegmentPending &&\n          state.segment === segment &&\n          encoder.getEncodedBytesCount() > SEGMENT_BYTES_LIMIT\n        ) {\n          flushSegment('segment_bytes_limit')\n        }\n      })\n    },\n\n    stop: function () {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    }\n  }\n}\n\nexport function computeSegmentContext(\n  configuration,\n  sessionManager,\n  viewContexts\n) {\n  var session = sessionManager.findTrackedSession()\n  var viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    sdk: {\n      name: configuration.sdkName,\n      version: configuration.sdkVersion\n    },\n    env: configuration.env || '',\n    service: viewContext.service || configuration.service || 'browser',\n    version: viewContext.version || configuration.version || '',\n    app: {\n      id: configuration.applicationId\n    },\n    session: {\n      id: session.id\n    },\n    view: {\n      id: viewContext.id\n    }\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n"],"mappings":"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","ignoreList":[]}