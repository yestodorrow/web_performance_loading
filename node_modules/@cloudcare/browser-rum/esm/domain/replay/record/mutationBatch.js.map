{"version":3,"file":"mutationBatch.js","names":["noop","monitor","MUTATION_PROCESS_MAX_DELAY","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","flush","addMutations","mutations","length","requestIdleCallback","timeout","Array","prototype","push","apply","stop","callback","opts","window","id","cancelIdleCallback","requestAnimationFrame","cancelAnimationFrame"],"sources":["../../../../src/domain/replay/record/mutationBatch.js"],"sourcesContent":["import { noop, monitor } from '@cloudcare/browser-core'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nvar MUTATION_PROCESS_MAX_DELAY = 100\n\nexport function createMutationBatch(processMutationBatch) {\n  var cancelScheduledFlush = noop\n  var pendingMutations = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  return {\n    addMutations: function (mutations) {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(flush, {\n          timeout: MUTATION_PROCESS_MAX_DELAY\n        })\n      }\n      //   pendingMutations.push(...mutations)\n      Array.prototype.push.apply(pendingMutations, mutations)\n    },\n\n    flush: flush,\n\n    stop: function () {\n      cancelScheduledFlush()\n    }\n  }\n}\n\nfunction requestIdleCallback(callback, opts) {\n  // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n  // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n  // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n  // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes\n  // efficiently.\n  if (window.requestIdleCallback) {\n    var id = window.requestIdleCallback(monitor(callback), opts)\n    return function () {\n      return window.cancelIdleCallback(id)\n    }\n  }\n  var id = window.requestAnimationFrame(monitor(callback))\n  return function () {\n    return window.cancelAnimationFrame(id)\n  }\n}\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,OAAO,QAAQ,yBAAyB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,0BAA0B,GAAG,GAAG;AAEpC,OAAO,SAASC,mBAAmBA,CAACC,oBAAoB,EAAE;EACxD,IAAIC,oBAAoB,GAAGL,IAAI;EAC/B,IAAIM,gBAAgB,GAAG,EAAE;EAEzB,SAASC,KAAKA,CAAA,EAAG;IACfF,oBAAoB,CAAC,CAAC;IACtBD,oBAAoB,CAACE,gBAAgB,CAAC;IACtCA,gBAAgB,GAAG,EAAE;EACvB;EAEA,OAAO;IACLE,YAAY,EAAE,SAAAA,aAAUC,SAAS,EAAE;MACjC,IAAIH,gBAAgB,CAACI,MAAM,KAAK,CAAC,EAAE;QACjCL,oBAAoB,GAAGM,mBAAmB,CAACJ,KAAK,EAAE;UAChDK,OAAO,EAAEV;QACX,CAAC,CAAC;MACJ;MACA;MACAW,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,KAAK,CAACV,gBAAgB,EAAEG,SAAS,CAAC;IACzD,CAAC;IAEDF,KAAK,EAAEA,KAAK;IAEZU,IAAI,EAAE,SAAAA,KAAA,EAAY;MAChBZ,oBAAoB,CAAC,CAAC;IACxB;EACF,CAAC;AACH;AAEA,SAASM,mBAAmBA,CAACO,QAAQ,EAAEC,IAAI,EAAE;EAC3C;EACA;EACA;EACA;EACA;EACA,IAAIC,MAAM,CAACT,mBAAmB,EAAE;IAC9B,IAAIU,EAAE,GAAGD,MAAM,CAACT,mBAAmB,CAACV,OAAO,CAACiB,QAAQ,CAAC,EAAEC,IAAI,CAAC;IAC5D,OAAO,YAAY;MACjB,OAAOC,MAAM,CAACE,kBAAkB,CAACD,EAAE,CAAC;IACtC,CAAC;EACH;EACA,IAAIA,EAAE,GAAGD,MAAM,CAACG,qBAAqB,CAACtB,OAAO,CAACiB,QAAQ,CAAC,CAAC;EACxD,OAAO,YAAY;IACjB,OAAOE,MAAM,CAACI,oBAAoB,CAACH,EAAE,CAAC;EACxC,CAAC;AACH","ignoreList":[]}