function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
import { noop, LifeCycleEventType, ViewLoadingType, addTelemetryDebug, ONE_MINUTE, elapsed, isElementNode } from '@cloudcare/browser-core';
import { supportPerformanceTimingEvent } from '../../performanceCollection';
import { getSelectorFromElement } from '../actions/getSelectorsFromElement';
import { getInteractionCount, initInteractionCountPolyfill } from './interactionCountPolyfill';

// Arbitrary value to prevent unnecessary memory usage on views with lots of interactions.
var MAX_INTERACTION_ENTRIES = 10;
export var MAX_INP_VALUE = 1 * ONE_MINUTE;

/**
 * Track the interaction to next paint (INP).
 * To avoid outliers, return the p98 worst interaction of the view.
 * Documentation: https://web.dev/inp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/main/src/onINP.ts
 */
export function trackInteractionToNextPaint(configuration, viewStart, viewLoadingType, lifeCycle) {
  if (!isInteractionToNextPaintSupported()) {
    return {
      getInteractionToNextPaint: function getInteractionToNextPaint() {
        return undefined;
      },
      setViewEnd: noop,
      stop: noop
    };
  }
  var _trackViewInteractionCount = trackViewInteractionCount(viewLoadingType);
  var getViewInteractionCount = _trackViewInteractionCount.getViewInteractionCount;
  var stopViewInteractionCount = _trackViewInteractionCount.stopViewInteractionCount;
  var viewEnd = Infinity;
  var longestInteractions = trackLongestInteractions(getViewInteractionCount);
  var interactionToNextPaint = -1;
  var interactionToNextPaintTargetSelector;
  var telemetryCollected = false;
  var subscribe = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, function (entries) {
    var _iterator = _createForOfIteratorHelper(entries),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var entry = _step.value;
        if ((entry.entryType === 'event' || entry.entryType === 'first-input') && entry.interactionId && entry.startTime >= viewStart && entry.startTime <= viewEnd) {
          longestInteractions.process(entry);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var newInteraction = longestInteractions.estimateP98Duration();
    if (newInteraction && newInteraction.duration !== interactionToNextPaint) {
      interactionToNextPaint = newInteraction.duration;
      if (interactionToNextPaint > 10 * ONE_MINUTE && !telemetryCollected) {
        var _newInteraction$targe;
        telemetryCollected = true;
        addTelemetryDebug('INP outlier', {
          inp: interactionToNextPaint,
          interaction: {
            timeFromViewStart: elapsed(viewStart, newInteraction.startTime),
            duration: newInteraction.duration,
            startTime: newInteraction.startTime,
            processingStart: newInteraction.processingStart,
            processingEnd: newInteraction.processingEnd,
            interactionId: newInteraction.interactionId,
            name: newInteraction.name,
            targetNodeName: (_newInteraction$targe = newInteraction.target) === null || _newInteraction$targe === void 0 ? void 0 : _newInteraction$targe.nodeName
          }
        });
      }
      if (newInteraction.target && isElementNode(newInteraction.target)) {
        interactionToNextPaintTargetSelector = getSelectorFromElement(newInteraction.target, configuration.actionNameAttribute);
      } else {
        interactionToNextPaintTargetSelector = undefined;
      }
    }
  });
  return {
    getInteractionToNextPaint: function getInteractionToNextPaint() {
      // If no INP duration where captured because of the performanceObserver 40ms threshold
      // but the view interaction count > 0 then report 0
      if (interactionToNextPaint >= 0) {
        return {
          value: Math.min(interactionToNextPaint, MAX_INP_VALUE),
          targetSelector: interactionToNextPaintTargetSelector
        };
      } else if (getViewInteractionCount()) {
        return {
          value: 0
        };
      }
    },
    setViewEnd: function setViewEnd(viewEndTime) {
      viewEnd = viewEndTime;
      stopViewInteractionCount();
    },
    stop: subscribe.unsubscribe
  };
}
function trackLongestInteractions(getViewInteractionCount) {
  var longestInteractions = [];
  function sortAndTrimLongestInteractions() {
    longestInteractions.sort(function (a, b) {
      return b.duration - a.duration;
    }).splice(MAX_INTERACTION_ENTRIES);
  }
  return {
    /**
     * Process the performance entry:
     * - if its duration is long enough, add the performance entry to the list of worst interactions
     * - if an entry with the same interaction id exists and its duration is lower than the new one, then replace it in the list of worst interactions
     */
    process: function process(entry) {
      var interactionIndex = longestInteractions.findIndex(function (interaction) {
        return entry.interactionId === interaction.interactionId;
      });
      var minLongestInteraction = longestInteractions[longestInteractions.length - 1];
      if (interactionIndex !== -1) {
        if (entry.duration > longestInteractions[interactionIndex].duration) {
          longestInteractions[interactionIndex] = entry;
          sortAndTrimLongestInteractions();
        }
      } else if (longestInteractions.length < MAX_INTERACTION_ENTRIES || entry.duration > minLongestInteraction.duration) {
        longestInteractions.push(entry);
        sortAndTrimLongestInteractions();
      }
    },
    /**
     * Compute the p98 longest interaction.
     * For better performance the computation is based on 10 longest interactions and the interaction count of the current view.
     */
    estimateP98Duration: function estimateP98Duration() {
      var interactionIndex = Math.min(longestInteractions.length - 1, Math.floor(getViewInteractionCount() / 50));
      return longestInteractions[interactionIndex];
    }
  };
}
export function trackViewInteractionCount(viewLoadingType) {
  initInteractionCountPolyfill();
  var previousInteractionCount = viewLoadingType === ViewLoadingType.INITIAL_LOAD ? 0 : getInteractionCount();
  var state = {
    stopped: false
  };
  function computeViewInteractionCount() {
    return getInteractionCount() - previousInteractionCount;
  }
  return {
    getViewInteractionCount: function getViewInteractionCount() {
      if (state.stopped) {
        return state.interactionCount;
      }
      return computeViewInteractionCount();
    },
    stopViewInteractionCount: function stopViewInteractionCount() {
      state = {
        stopped: true,
        interactionCount: computeViewInteractionCount()
      };
    }
  };
}
export function isInteractionToNextPaintSupported() {
  return supportPerformanceTimingEvent('event') && window.PerformanceEventTiming && 'interactionId' in PerformanceEventTiming.prototype;
}
//# sourceMappingURL=trackInteractionToNextPaint.js.map