"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PAGE_ACTIVITY_VALIDATION_DELAY = exports.PAGE_ACTIVITY_END_DELAY = void 0;
exports.createPageActivityObservable = createPageActivityObservable;
exports.doWaitPageActivityEnd = doWaitPageActivityEnd;
exports.waitPageActivityEnd = waitPageActivityEnd;
var _browserCore = require("@cloudcare/browser-core");
// Delay to wait for a page activity to validate the tracking process
var PAGE_ACTIVITY_VALIDATION_DELAY = 100;
// Delay to wait after a page activity to end the tracking process
exports.PAGE_ACTIVITY_VALIDATION_DELAY = PAGE_ACTIVITY_VALIDATION_DELAY;
var PAGE_ACTIVITY_END_DELAY = 100;

/**
 * Wait for the page activity end
 *
 * Detection lifecycle:
 * ```
 *                        Wait page activity end
 *              .-------------------'--------------------.
 *              v                                        v
 *     [Wait for a page activity ]          [Wait for a maximum duration]
 *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]
 *          /                  \                           |
 *         v                    v                          |
 *  [No page activity]   [Page activity]                   |
 *         |                   |,----------------------.   |
 *         v                   v                       |   |
 *     (Discard)     [Wait for a page activity]        |   |
 *                   [   timeout: END_DELAY   ]        |   |
 *                       /                \            |   |
 *                      v                  v           |   |
 *             [No page activity]    [Page activity]   |   |
 *                      |                 |            |   |
 *                      |                 '------------'   |
 *                      '-----------. ,--------------------'
 *                                   v
 *                                 (End)
 * ```
 *
 * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the
 * process is still alive after maxDuration, it has been validated.
 */
exports.PAGE_ACTIVITY_END_DELAY = PAGE_ACTIVITY_END_DELAY;
function waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, pageActivityEndCallback, maxDuration) {
  var pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration);
  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration);
}
function doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration) {
  var pageActivityEndTimeoutId;
  var hasCompleted = false;
  var validationTimeoutId = (0, _browserCore.setTimeout)(function () {
    complete({
      hadActivity: false
    });
  }, PAGE_ACTIVITY_VALIDATION_DELAY);
  var maxDurationTimeoutId = maxDuration !== undefined ? (0, _browserCore.setTimeout)(function () {
    return complete({
      hadActivity: true,
      end: (0, _browserCore.timeStampNow)()
    });
  }, maxDuration) : undefined;
  var pageActivitySubscription = pageActivityObservable.subscribe(function (data) {
    var isBusy = data.isBusy;
    (0, _browserCore.clearTimeout)(validationTimeoutId);
    (0, _browserCore.clearTimeout)(pageActivityEndTimeoutId);
    var lastChangeTime = (0, _browserCore.timeStampNow)();
    if (!isBusy) {
      pageActivityEndTimeoutId = (0, _browserCore.setTimeout)(function () {
        complete({
          hadActivity: true,
          end: lastChangeTime
        });
      }, PAGE_ACTIVITY_END_DELAY);
    }
  });
  var stop = function stop() {
    hasCompleted = true;
    (0, _browserCore.clearTimeout)(validationTimeoutId);
    (0, _browserCore.clearTimeout)(pageActivityEndTimeoutId);
    (0, _browserCore.clearTimeout)(maxDurationTimeoutId);
    pageActivitySubscription.unsubscribe();
  };
  function complete(event) {
    if (hasCompleted) {
      return;
    }
    stop();
    pageActivityEndCallback(event);
  }
  return {
    stop: stop
  };
}
function createPageActivityObservable(lifeCycle, domMutationObservable, configuration) {
  return new _browserCore.Observable(function (observable) {
    var subscriptions = [];
    var firstRequestIndex;
    var pendingRequestsCount = 0;
    subscriptions.push(domMutationObservable.subscribe(notifyPageActivity), lifeCycle.subscribe(_browserCore.LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, function (entries) {
      if ((0, _browserCore.some)(entries, function (entry) {
        return entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name);
      })) {
        notifyPageActivity();
      }
    }), lifeCycle.subscribe(_browserCore.LifeCycleEventType.REQUEST_STARTED, function (startEvent) {
      if (isExcludedUrl(configuration, startEvent.url)) {
        return;
      }
      if (firstRequestIndex === undefined) {
        firstRequestIndex = startEvent.requestIndex;
      }
      pendingRequestsCount += 1;
      notifyPageActivity();
    }), lifeCycle.subscribe(_browserCore.LifeCycleEventType.REQUEST_COMPLETED, function (request) {
      if (isExcludedUrl(configuration, request.url) || firstRequestIndex === undefined ||
      // If the request started before the tracking start, ignore it
      request.requestIndex < firstRequestIndex) {
        return;
      }
      pendingRequestsCount -= 1;
      notifyPageActivity();
    }));
    var _trackWindowOpen = trackWindowOpen(notifyPageActivity);
    var stopTrackingWindowOpen = _trackWindowOpen.stop;
    return function () {
      stopTrackingWindowOpen();
      (0, _browserCore.each)(subscriptions, function (s) {
        s.unsubscribe();
      });
    };
    function notifyPageActivity() {
      observable.notify({
        isBusy: pendingRequestsCount > 0
      });
    }
  });
}
function isExcludedUrl(configuration, requestUrl) {
  return (0, _browserCore.matchList)(configuration.excludedActivityUrls, requestUrl);
}
function trackWindowOpen(callback) {
  return (0, _browserCore.instrumentMethodAndCallOriginal)(window, 'open', {
    before: callback
  });
}
//# sourceMappingURL=waitPageActivityEnd.js.map