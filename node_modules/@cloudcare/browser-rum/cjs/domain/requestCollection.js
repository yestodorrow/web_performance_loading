"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startRequestCollection = startRequestCollection;
exports.trackFetch = trackFetch;
exports.trackXhr = trackXhr;
var _browserCore = require("@cloudcare/browser-core");
var _resourceUtils = require("./rumEventsCollection/resource/resourceUtils");
var _tracer = require("./tracing/tracer");
var nextRequestIndex = 1;
function startRequestCollection(lifeCycle, configuration, sessionManager) {
  var tracer = (0, _tracer.startTracer)(configuration, sessionManager);
  trackXhr(lifeCycle, configuration, tracer);
  trackFetch(lifeCycle, configuration, tracer);
}
function trackXhr(lifeCycle, configuration, tracer) {
  var subscription = (0, _browserCore.initXhrObservable)().subscribe(function (rawContext) {
    var context = rawContext;
    if (!(0, _resourceUtils.isAllowedRequestUrl)(configuration, context.url)) {
      return;
    }
    switch (context.state) {
      case 'start':
        tracer.traceXhr(context, context.xhr);
        context.requestIndex = getNextRequestIndex();
        lifeCycle.notify(_browserCore.LifeCycleEventType.REQUEST_STARTED, {
          requestIndex: context.requestIndex,
          url: context.url
        });
        break;
      case 'complete':
        tracer.clearTracingIfNeeded(context);
        lifeCycle.notify(_browserCore.LifeCycleEventType.REQUEST_COMPLETED, {
          duration: context.duration,
          method: context.method,
          requestIndex: context.requestIndex,
          spanId: context.spanId,
          startClocks: context.startClocks,
          status: context.status,
          traceId: context.traceId,
          traceSampled: context.traceSampled,
          type: _browserCore.RequestType.XHR,
          url: context.url,
          xhr: context.xhr
        });
        break;
    }
  });
  return {
    stop: function stop() {
      return subscription.unsubscribe();
    }
  };
}
function trackFetch(lifeCycle, configuration, tracer) {
  var subscription = (0, _browserCore.initFetchObservable)().subscribe(function (rawContext) {
    var context = rawContext;
    if (!(0, _resourceUtils.isAllowedRequestUrl)(configuration, context.url)) {
      return;
    }
    switch (context.state) {
      case 'start':
        tracer.traceFetch(context);
        context.requestIndex = getNextRequestIndex();
        lifeCycle.notify(_browserCore.LifeCycleEventType.REQUEST_STARTED, {
          requestIndex: context.requestIndex,
          url: context.url
        });
        break;
      case 'resolve':
        waitForResponseToComplete(context, function (duration) {
          tracer.clearTracingIfNeeded(context);
          lifeCycle.notify(_browserCore.LifeCycleEventType.REQUEST_COMPLETED, {
            duration: duration,
            method: context.method,
            requestIndex: context.requestIndex,
            responseType: context.responseType,
            spanId: context.spanId,
            startClocks: context.startClocks,
            status: context.status,
            traceId: context.traceId,
            traceSampled: context.traceSampled,
            type: _browserCore.RequestType.FETCH,
            url: context.url,
            response: context.response,
            init: context.init,
            input: context.input
          });
        });
        break;
    }
  });
  return {
    stop: function stop() {
      return subscription.unsubscribe();
    }
  };
}
function getNextRequestIndex() {
  var result = nextRequestIndex;
  nextRequestIndex += 1;
  return result;
}
function waitForResponseToComplete(context, callback) {
  var clonedResponse = context.response && (0, _browserCore.tryToClone)(context.response);
  if (!clonedResponse || !clonedResponse.body) {
    // do not try to wait for the response if the clone failed, fetch error or null body
    callback((0, _browserCore.elapsed)(context.startClocks.timeStamp, (0, _browserCore.timeStampNow)()));
  } else {
    (0, _browserCore.readBytesFromStream)(clonedResponse.body, function () {
      callback((0, _browserCore.elapsed)(context.startClocks.timeStamp, (0, _browserCore.timeStampNow)()));
    }, {
      bytesLimit: Number.POSITIVE_INFINITY,
      collectStreamBody: false
    });
  }
}
//# sourceMappingURL=requestCollection.js.map