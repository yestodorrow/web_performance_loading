"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CLICK_ACTION_MAX_DURATION = exports.ACTION_CONTEXT_TIME_OUT_DELAY = void 0;
exports.finalizeClicks = finalizeClicks;
exports.trackClickActions = trackClickActions;
var _browserCore = require("@cloudcare/browser-core");
var _trackEventCounts = require("../../trackEventCounts");
var _waitPageActivityEnd2 = require("../../waitPageActivityEnd");
var _clickChain = require("./clickChain");
var _getActionNameFromElement = require("./getActionNameFromElement");
var _getSelectorsFromElement = require("./getSelectorsFromElement");
var _listenActionEvents2 = require("./listenActionEvents");
var _computeFrustration2 = require("./computeFrustration");
// import { getSelectorsFromElement } from './getSelectorsFromElement'

// Maximum duration for click actions
var CLICK_ACTION_MAX_DURATION = 10 * _browserCore.ONE_SECOND;
exports.CLICK_ACTION_MAX_DURATION = CLICK_ACTION_MAX_DURATION;
var ACTION_CONTEXT_TIME_OUT_DELAY = 5 * _browserCore.ONE_MINUTE; // arbitrary
exports.ACTION_CONTEXT_TIME_OUT_DELAY = ACTION_CONTEXT_TIME_OUT_DELAY;
function trackClickActions(lifeCycle, domMutationObservable, configuration) {
  var history = new _browserCore.ContextHistory(ACTION_CONTEXT_TIME_OUT_DELAY);
  var stopObservable = new _browserCore.Observable();
  var currentClickChain;
  lifeCycle.subscribe(_browserCore.LifeCycleEventType.SESSION_RENEWED, function () {
    history.reset();
  });
  lifeCycle.subscribe(_browserCore.LifeCycleEventType.VIEW_ENDED, stopClickChain);
  var _listenActionEvents = (0, _listenActionEvents2.listenActionEvents)({
    onPointerDown: function onPointerDown(pointerDownEvent) {
      return processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent);
    },
    onPointerUp: function onPointerUp(data, startEvent, getUserActivity) {
      startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, data.clickActionBase, startEvent, getUserActivity, data.hadActivityOnPointerDown);
    }
  });
  var stopActionEventsListener = _listenActionEvents.stop;
  var actionContexts = {
    findActionId: function findActionId(startTime) {
      var allIds = history.findAll(startTime);
      if (allIds && allIds.length) {
        return allIds[allIds.length - 1];
      }
      return undefined;
    },
    findAllActionId: function findAllActionId(startTime) {
      return history.findAll(startTime);
    }
  };
  return {
    stop: function stop() {
      stopClickChain();
      stopObservable.notify();
      stopActionEventsListener();
    },
    actionContexts: actionContexts
  };
  function stopClickChain() {
    if (currentClickChain) {
      currentClickChain.stop();
    }
  }
  function appendClickToClickChain(click) {
    if (!currentClickChain || !currentClickChain.tryAppend(click)) {
      var rageClick = click.clone();
      currentClickChain = (0, _clickChain.createClickChain)(click, function (clicks) {
        finalizeClicks(clicks, rageClick);
      });
    }
  }
}
function processPointerDown(configuration, lifeCycle, domMutationObservable, pointerDownEvent) {
  var clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute);
  var _hadActivityOnPointerDown = false;
  (0, _waitPageActivityEnd2.waitPageActivityEnd)(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {
    _hadActivityOnPointerDown = pageActivityEndEvent.hadActivity;
  }, _waitPageActivityEnd2.PAGE_ACTIVITY_VALIDATION_DELAY);
  return {
    clickActionBase: clickActionBase,
    hadActivityOnPointerDown: function hadActivityOnPointerDown() {
      return _hadActivityOnPointerDown;
    }
  };
}
function startClickAction(configuration, lifeCycle, domMutationObservable, history, stopObservable, appendClickToClickChain, clickActionBase, startEvent, getUserActivity, hadActivityOnPointerDown) {
  var click = newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);
  appendClickToClickChain(click);
  var _waitPageActivityEnd = (0, _waitPageActivityEnd2.waitPageActivityEnd)(lifeCycle, domMutationObservable, configuration, function (pageActivityEndEvent) {
    if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {
      // If the clock is looking weird, just discard the click
      click.discard();
    } else {
      if (pageActivityEndEvent.hadActivity) {
        click.stop(pageActivityEndEvent.end);
      } else if (hadActivityOnPointerDown()) {
        click.stop(
        // using the click start as activity end, so the click will have some activity but its
        // duration will be 0 (as the activity started before the click start)
        click.startClocks.timeStamp);
      } else {
        click.stop();
      }
    }
  }, CLICK_ACTION_MAX_DURATION);
  var stopWaitPageActivityEnd = _waitPageActivityEnd.stop;
  var viewEndedSubscription = lifeCycle.subscribe(_browserCore.LifeCycleEventType.VIEW_ENDED, function (data) {
    click.stop(data.endClocks.timeStamp);
  });
  var stopSubscription = stopObservable.subscribe(function () {
    click.stop();
  });
  click.stopObservable.subscribe(function () {
    viewEndedSubscription.unsubscribe();
    stopWaitPageActivityEnd();
    stopSubscription.unsubscribe();
  });
}
function computeClickActionBase(event, actionNameAttribute) {
  var rect = event.target.getBoundingClientRect();
  return {
    type: _browserCore.ActionType.CLICK,
    target: {
      width: Math.round(rect.width),
      height: Math.round(rect.height),
      selector: (0, _getSelectorsFromElement.getSelectorFromElement)(event.target, actionNameAttribute)
    },
    position: {
      x: Math.round(event.clientX - rect.left),
      y: Math.round(event.clientY - rect.top)
    },
    name: (0, _getActionNameFromElement.getActionNameFromElement)(event.target, actionNameAttribute)
  };
}
var ClickStatus = {
  // Initial state, the click is still ongoing.
  ONGOING: 0,
  // The click is no more ongoing but still needs to be validated or discarded.
  STOPPED: 1,
  // Final state, the click has been stopped and validated or discarded.
  FINALIZED: 2
};
function newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent) {
  var id = (0, _browserCore.UUID)();
  var startClocks = (0, _browserCore.clocksNow)();
  var historyEntry = history.add(id, startClocks.relative);
  var eventCountsSubscription = (0, _trackEventCounts.trackEventCounts)({
    lifeCycle: lifeCycle,
    isChildEvent: function isChildEvent(event) {
      return event.action !== undefined && ((0, _browserCore.isArray)(event.action.ids) ? (0, _browserCore.includes)(event.action.ids, id) : event.action.ids === id);
    }
  });
  var status = ClickStatus.ONGOING;
  var activityEndTime;
  var frustrationTypes = [];
  var stopObservable = new _browserCore.Observable();
  function stop(newActivityEndTime) {
    if (status !== ClickStatus.ONGOING) {
      return;
    }
    activityEndTime = newActivityEndTime;
    status = ClickStatus.STOPPED;
    if (activityEndTime) {
      historyEntry.close((0, _browserCore.getRelativeTime)(activityEndTime));
    } else {
      historyEntry.remove();
    }
    eventCountsSubscription.stop();
    stopObservable.notify();
  }
  return {
    event: startEvent,
    stop: stop,
    stopObservable: stopObservable,
    hasError: function hasError() {
      return eventCountsSubscription.eventCounts.errorCount > 0;
    },
    hasPageActivity: function hasPageActivity() {
      return activityEndTime !== undefined;
    },
    getUserActivity: getUserActivity,
    addFrustration: function addFrustration(frustrationType) {
      frustrationTypes.push(frustrationType);
    },
    startClocks: startClocks,
    isStopped: function isStopped() {
      return status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED;
    },
    clone: function clone() {
      return newClick(lifeCycle, history, getUserActivity, clickActionBase, startEvent);
    },
    validate: function validate(domEvents) {
      stop();
      if (status !== ClickStatus.STOPPED) {
        return;
      }
      var _eventCountsSubscription = eventCountsSubscription.eventCounts;
      var resourceCount = _eventCountsSubscription.resourceCount;
      var errorCount = _eventCountsSubscription.errorCount;
      var longTaskCount = _eventCountsSubscription.longTaskCount;
      var clickAction = (0, _browserCore.assign)({
        type: _browserCore.ActionType.CLICK,
        duration: activityEndTime && (0, _browserCore.elapsed)(startClocks.timeStamp, activityEndTime),
        startClocks: startClocks,
        id: id,
        frustrationTypes: frustrationTypes,
        counts: {
          resourceCount: resourceCount,
          errorCount: errorCount,
          longTaskCount: longTaskCount
        },
        events: (0, _browserCore.isNullUndefinedDefaultValue)(domEvents, [startEvent]),
        event: startEvent
      }, clickActionBase);
      lifeCycle.notify(_browserCore.LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction);
      status = ClickStatus.FINALIZED;
    },
    discard: function discard() {
      stop();
      status = ClickStatus.FINALIZED;
    }
  };
}
function finalizeClicks(clicks, rageClick) {
  var _computeFrustration = (0, _computeFrustration2.computeFrustration)(clicks, rageClick);
  var isRage = _computeFrustration.isRage;
  if (isRage) {
    (0, _browserCore.each)(clicks, function (click) {
      click.discard();
    });
    rageClick.stop((0, _browserCore.timeStampNow)());
    rageClick.validate((0, _browserCore.map)(clicks, function (click) {
      return click.event;
    }));
  } else {
    rageClick.discard();
    (0, _browserCore.each)(clicks, function (click) {
      click.validate();
    });
  }
}
//# sourceMappingURL=trackClickActions.js.map