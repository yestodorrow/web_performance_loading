"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.THROTTLE_SCROLL_DURATION = void 0;
exports.computeScrollValues = computeScrollValues;
exports.createScrollValuesObservable = createScrollValuesObservable;
exports.trackScrollMetrics = trackScrollMetrics;
var _browserCore = require("@cloudcare/browser-core");
var _initViewportObservable = require("../../initViewportObservable");
/** Arbitrary scroll throttle duration */
var THROTTLE_SCROLL_DURATION = _browserCore.ONE_SECOND;
exports.THROTTLE_SCROLL_DURATION = THROTTLE_SCROLL_DURATION;
function trackScrollMetrics(configuration, viewStart, callback, scrollValues) {
  if (scrollValues === undefined) {
    scrollValues = createScrollValuesObservable(configuration);
  }
  var maxScrollDepth = 0;
  var maxScrollHeight = 0;
  var maxScrollHeightTime = 0;
  var subscription = scrollValues.subscribe(function (data) {
    var scrollDepth = data.scrollDepth;
    var scrollTop = data.scrollTop;
    var scrollHeight = data.scrollHeight;
    var shouldUpdate = false;
    if (scrollDepth > maxScrollDepth) {
      maxScrollDepth = scrollDepth;
      shouldUpdate = true;
    }
    if (scrollHeight > maxScrollHeight) {
      maxScrollHeight = scrollHeight;
      var now = (0, _browserCore.relativeNow)();
      maxScrollHeightTime = (0, _browserCore.elapsed)(viewStart.relative, now);
      shouldUpdate = true;
    }
    if (shouldUpdate) {
      callback({
        maxDepth: Math.min(maxScrollDepth, maxScrollHeight),
        maxDepthScrollTop: scrollTop,
        maxScrollHeight: maxScrollHeight,
        maxScrollHeightTime: maxScrollHeightTime
      });
    }
  });
  return {
    stop: function stop() {
      return subscription.unsubscribe();
    }
  };
}
function computeScrollValues() {
  var scrollTop = (0, _browserCore.getScrollY)();
  var viewport = (0, _initViewportObservable.getViewportDimension)();
  var height = viewport.height;
  var scrollHeight = Math.round((document.scrollingElement || document.documentElement).scrollHeight);
  var scrollDepth = Math.round(height + scrollTop);
  return {
    scrollHeight: scrollHeight,
    scrollDepth: scrollDepth,
    scrollTop: scrollTop
  };
}
function createScrollValuesObservable(configuration, throttleDuration) {
  if (throttleDuration === undefined) {
    throttleDuration = THROTTLE_SCROLL_DURATION;
  }
  return new _browserCore.Observable(function (observable) {
    function notify() {
      observable.notify(computeScrollValues());
    }
    if (window.ResizeObserver) {
      var throttledNotify = (0, _browserCore.throttle)(notify, throttleDuration, {
        leading: false,
        trailing: true
      });
      var observerTarget = document.scrollingElement || document.documentElement;
      var resizeObserver = new ResizeObserver((0, _browserCore.monitor)(throttledNotify.throttled));
      resizeObserver.observe(observerTarget);
      var eventListener = (0, _browserCore.addEventListener)(window, _browserCore.DOM_EVENT.SCROLL, throttledNotify.throttled, {
        passive: true
      });
      return function () {
        throttledNotify.cancel();
        resizeObserver.unobserve(observerTarget);
        eventListener.stop();
      };
    }
  });
}
//# sourceMappingURL=trackScrollMetrics.js.map