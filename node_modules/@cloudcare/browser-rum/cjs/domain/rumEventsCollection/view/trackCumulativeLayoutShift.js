"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLayoutShiftSupported = isLayoutShiftSupported;
exports.trackCumulativeLayoutShift = trackCumulativeLayoutShift;
var _browserCore = require("@cloudcare/browser-core");
var _performanceCollection = require("../../performanceCollection");
var _getSelectorsFromElement = require("../actions/getSelectorsFromElement");
/**
 * Track the cumulative layout shifts (CLS).
 * Layout shifts are grouped into session windows.
 * The minimum gap between session windows is 1 second.
 * The maximum duration of a session window is 5 second.
 * The session window layout shift value is the sum of layout shifts inside it.
 * The CLS value is the max of session windows values.
 *
 * This yields a new value whenever the CLS value is updated (a higher session window value is computed).
 *
 * See isLayoutShiftSupported to check for browser support.
 *
 * Documentation:
 * https://web.dev/cls/
 * https://web.dev/evolving-cls/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts
 */
function trackCumulativeLayoutShift(lifeCycle, configuration, callback) {
  if (!isLayoutShiftSupported()) {
    return {
      stop: _browserCore.noop
    };
  }
  var maxClsValue = 0;
  callback({
    value: 0
  });
  var window = slidingSessionWindow();
  var _subscribe = lifeCycle.subscribe(_browserCore.LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, function (entries) {
    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
        window.update(entry);
        if (window.value() > maxClsValue) {
          maxClsValue = window.value();
          var cls = (0, _browserCore.round)(maxClsValue, 4);
          var clsTarget = window.largestLayoutShiftTarget();
          var cslTargetSelector;
          if (clsTarget &&
          // 检测目标是否在dom 中被删除
          clsTarget.isConnected) {
            cslTargetSelector = (0, _getSelectorsFromElement.getSelectorFromElement)(clsTarget, configuration.actionNameAttribute);
          }
          callback({
            value: cls,
            targetSelector: cslTargetSelector
          });
        }
      }
    }
  });
  var stop = _subscribe.unsubscribe;
  return {
    stop: stop
  };
}
function slidingSessionWindow() {
  var _value = 0;
  var startTime;
  var endTime;
  var largestLayoutShift = 0;
  var _largestLayoutShiftTarget;
  var _largestLayoutShiftTime;
  return {
    update: function update(entry) {
      var shouldCreateNewWindow = startTime === undefined || entry.startTime - endTime >= _browserCore.ONE_SECOND || entry.startTime - startTime >= 5 * _browserCore.ONE_SECOND;
      if (shouldCreateNewWindow) {
        startTime = endTime = entry.startTime;
        _value = entry.value;
        largestLayoutShift = 0;
        _largestLayoutShiftTarget = undefined;
      } else {
        _value += entry.value;
        endTime = entry.startTime;
      }
      if (entry.value > largestLayoutShift) {
        largestLayoutShift = entry.value;
        _largestLayoutShiftTime = entry.startTime;
        if (entry.sources && entry.sources.length) {
          var findTarget = (0, _browserCore.find)(entry.sources, function (s) {
            return !!s.node && (0, _browserCore.isElementNode)(s.node);
          });
          if (findTarget) {
            _largestLayoutShiftTarget = findTarget.node;
          }
        } else {
          _largestLayoutShiftTarget = undefined;
        }
      }
    },
    value: function value() {
      return _value;
    },
    largestLayoutShiftTarget: function largestLayoutShiftTarget() {
      return _largestLayoutShiftTarget;
    },
    largestLayoutShiftTime: function largestLayoutShiftTime() {
      return _largestLayoutShiftTime;
    }
  };
}

/**
 * Check whether `layout-shift` is supported by the browser.
 */
function isLayoutShiftSupported() {
  return (0, _performanceCollection.supportPerformanceTimingEvent)('layout-shift');
}
//# sourceMappingURL=trackCumulativeLayoutShift.js.map