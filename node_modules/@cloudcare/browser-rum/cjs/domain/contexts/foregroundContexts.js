"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS = exports.MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS = void 0;
exports.addNewForegroundPeriod = addNewForegroundPeriod;
exports.closeForegroundPeriod = closeForegroundPeriod;
exports.startForegroundContexts = startForegroundContexts;
var _browserCore = require("@cloudcare/browser-core");
// Arbitrary value to cap number of element mostly for backend & to save bandwidth
var MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS = 500;
// Arbitrary value to cap number of element mostly for memory consumption in the browser
exports.MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS = MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS;
var MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS = 2500;
exports.MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS = MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS;
var foregroundPeriods = [];
function startForegroundContexts() {
  if (document.hasFocus()) {
    addNewForegroundPeriod();
  }
  var foregroundTracking = trackFocus(addNewForegroundPeriod);
  var blurTracking = trackBlur(closeForegroundPeriod);
  return {
    isInForegroundAt: isInForegroundAt,
    selectInForegroundPeriodsFor: selectInForegroundPeriodsFor,
    stop: function stop() {
      foregroundPeriods = [];
      foregroundTracking.stop();
      blurTracking.stop();
    }
  };
}
function addNewForegroundPeriod() {
  if (foregroundPeriods.length > MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS) {
    return;
  }
  var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
  var now = (0, _browserCore.relativeNow)();
  if (currentForegroundPeriod !== undefined && currentForegroundPeriod.end === undefined) {
    return;
  }
  foregroundPeriods.push({
    start: now
  });
}
function closeForegroundPeriod() {
  if (foregroundPeriods.length === 0) {
    return;
  }
  var currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1];
  var now = (0, _browserCore.relativeNow)();
  if (currentForegroundPeriod.end !== undefined) {
    return;
  }
  currentForegroundPeriod.end = now;
}
function trackFocus(onFocusChange) {
  return (0, _browserCore.addEventListener)(window, _browserCore.DOM_EVENT.FOCUS, function (event) {
    if (!event.isTrusted) {
      return;
    }
    onFocusChange();
  });
}
function trackBlur(onBlurChange) {
  return (0, _browserCore.addEventListener)(window, _browserCore.DOM_EVENT.BLUR, function (event) {
    if (!event.isTrusted) {
      return;
    }
    onBlurChange();
  });
}
function isInForegroundAt(startTime) {
  for (var i = foregroundPeriods.length - 1; i >= 0; i--) {
    var foregroundPeriod = foregroundPeriods[i];
    if (foregroundPeriod.end !== undefined && startTime > foregroundPeriod.end) {
      break;
    }
    if (startTime > foregroundPeriod.start && (foregroundPeriod.end === undefined || startTime < foregroundPeriod.end)) {
      return true;
    }
  }
  return false;
}
function selectInForegroundPeriodsFor(eventStartTime, duration) {
  var eventEndTime = (0, _browserCore.addDuration)(eventStartTime, duration);
  var filteredForegroundPeriods = [];
  var earliestIndex = Math.max(0, foregroundPeriods.length - MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS);
  for (var i = foregroundPeriods.length - 1; i >= earliestIndex; i--) {
    var foregroundPeriod = foregroundPeriods[i];
    if (foregroundPeriod.end !== undefined && eventStartTime > foregroundPeriod.end) {
      // event starts after the end of the current focus period
      // since the array is sorted, we can stop looking for foreground periods
      break;
    }
    if (eventEndTime < foregroundPeriod.start) {
      // event ends before the start of the current focus period
      // continue to previous one
      continue;
    }
    var startTime = eventStartTime > foregroundPeriod.start ? eventStartTime : foregroundPeriod.start;
    var startDuration = (0, _browserCore.elapsed)(eventStartTime, startTime);
    var endTime = foregroundPeriod.end === undefined || eventEndTime < foregroundPeriod.end ? eventEndTime : foregroundPeriod.end;
    var endDuration = (0, _browserCore.elapsed)(startTime, endTime);
    filteredForegroundPeriods.unshift({
      start: (0, _browserCore.toServerDuration)(startDuration),
      duration: (0, _browserCore.toServerDuration)(endDuration)
    });
  }
  return filteredForegroundPeriods;
}
//# sourceMappingURL=foregroundContexts.js.map