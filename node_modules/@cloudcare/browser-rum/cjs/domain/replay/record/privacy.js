"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.censorText = exports.MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = void 0;
exports.getNodePrivacyLevel = getNodePrivacyLevel;
exports.getNodeSelfPrivacyLevel = getNodeSelfPrivacyLevel;
exports.getTextContent = getTextContent;
exports.reducePrivacyLevel = reducePrivacyLevel;
exports.shouldIgnoreElement = shouldIgnoreElement;
exports.shouldMaskNode = shouldMaskNode;
var _browserCore = require("@cloudcare/browser-core");
var _constants = require("../../../constants");
var MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100000;
exports.MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = MAX_ATTRIBUTE_VALUE_CHAR_LENGTH;
var TEXT_MASKING_CHAR = 'x';

/**
 * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is
 * know, it is best to use something like:
 *
 * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)
 */
function getNodePrivacyLevel(node, defaultPrivacyLevel, cache) {
  if (cache && cache.has(node)) {
    return cache.get(node);
  }
  var parentNode = (0, _browserCore.getParentNode)(node);
  var parentNodePrivacyLevel = parentNode ? getNodePrivacyLevel(parentNode, defaultPrivacyLevel) : defaultPrivacyLevel;
  var selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node);
  var nodePrivacyLevel = reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel);
  if (cache) {
    cache.set(node, nodePrivacyLevel);
  }
  return nodePrivacyLevel;
}

/**
 * Reduces the next privacy level based on self + parent privacy levels
 */
function reducePrivacyLevel(childPrivacyLevel, parentNodePrivacyLevel) {
  switch (parentNodePrivacyLevel) {
    // These values cannot be overridden
    case _constants.NodePrivacyLevel.HIDDEN:
    case _constants.NodePrivacyLevel.IGNORE:
      return parentNodePrivacyLevel;
  }
  switch (childPrivacyLevel) {
    case _constants.NodePrivacyLevel.ALLOW:
    case _constants.NodePrivacyLevel.MASK:
    case _constants.NodePrivacyLevel.MASK_USER_INPUT:
    case _constants.NodePrivacyLevel.HIDDEN:
    case _constants.NodePrivacyLevel.IGNORE:
      return childPrivacyLevel;
    default:
      return parentNodePrivacyLevel;
  }
}

/**
 * Determines the node's own privacy level without checking for ancestors.
 */
function getNodeSelfPrivacyLevel(node) {
  // Only Element types can have a privacy level set
  if (!(0, _browserCore.isElementNode)(node)) {
    return;
  }
  var privAttr = node.getAttribute(_constants.PRIVACY_ATTR_NAME);

  // Overrules for replay purpose
  if (node.tagName === 'BASE') {
    return _constants.NodePrivacyLevel.ALLOW;
  }

  // Overrules to enforce end-user protection
  if (node.tagName === 'INPUT') {
    var inputElement = node;
    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {
      return _constants.NodePrivacyLevel.MASK;
    }
    if (inputElement.type === 'hidden') {
      return _constants.NodePrivacyLevel.MASK;
    }
    var autocomplete = inputElement.getAttribute('autocomplete');
    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]
    if (autocomplete && autocomplete.indexOf('cc-') === 0) {
      return _constants.NodePrivacyLevel.MASK;
    }
  }

  // Check HTML privacy attributes and classes
  if (privAttr === _constants.PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(_constants.PRIVACY_CLASS_HIDDEN)) {
    return _constants.NodePrivacyLevel.HIDDEN;
  }
  if (privAttr === _constants.PRIVACY_ATTR_VALUE_MASK || node.classList.contains(_constants.PRIVACY_CLASS_MASK)) {
    return _constants.NodePrivacyLevel.MASK;
  }
  if (privAttr === _constants.PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(_constants.PRIVACY_CLASS_MASK_USER_INPUT)) {
    return _constants.NodePrivacyLevel.MASK_USER_INPUT;
  }
  if (privAttr === _constants.PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(_constants.PRIVACY_CLASS_ALLOW)) {
    return _constants.NodePrivacyLevel.ALLOW;
  }
  if (shouldIgnoreElement(node)) {
    return _constants.NodePrivacyLevel.IGNORE;
  }
}

/**
 * Helper aiming to unify `mask` and `mask-user-input` privacy levels:
 *
 * In the `mask` case, it is trivial: we should mask the element.
 *
 * In the `mask-user-input` case, we should mask the element only if it is a "form" element or the
 * direct parent is a form element for text nodes).
 *
 * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a
 * node if it is ignored or hidden? it doesn't matter since it won't be serialized).
 */
function shouldMaskNode(node, privacyLevel) {
  switch (privacyLevel) {
    case _constants.NodePrivacyLevel.MASK:
    case _constants.NodePrivacyLevel.HIDDEN:
    case _constants.NodePrivacyLevel.IGNORE:
      return true;
    case _constants.NodePrivacyLevel.MASK_USER_INPUT:
      return (0, _browserCore.isTextNode)(node) ? isFormElement(node.parentNode) : isFormElement(node);
    default:
      return false;
  }
}
function isFormElement(node) {
  if (!node || node.nodeType !== node.ELEMENT_NODE) {
    return false;
  }
  var element = node;
  if (element.tagName === 'INPUT') {
    switch (element.type) {
      case 'button':
      case 'color':
      case 'reset':
      case 'submit':
        return false;
    }
  }
  return !!_constants.FORM_PRIVATE_TAG_NAMES[element.tagName];
}

/**
 * Text censoring non-destructively maintains whitespace characters in order to preserve text shape
 * during replay.
 */
var censorText = function censorText(text) {
  return text.replace(/\S/g, TEXT_MASKING_CHAR);
};
exports.censorText = censorText;
function getTextContent(textNode, ignoreWhiteSpace, parentNodePrivacyLevel) {
  // The parent node may not be a html element which has a tagName attribute.
  // So just let it be undefined which is ok in this use case.
  var parentTagName = textNode.parentElement && textNode.parentElement.tagName;
  var textContent = textNode.textContent || '';
  if (ignoreWhiteSpace && !textContent.trim()) {
    return;
  }
  var nodePrivacyLevel = parentNodePrivacyLevel;

  //   var isStyle = parentTagName === 'STYLE' ? true : undefined
  var isScript = parentTagName === 'SCRIPT';
  if (isScript) {
    // For perf reasons, we don't record script (heuristic)
    textContent = _constants.CENSORED_STRING_MARK;
  } else if (nodePrivacyLevel === _constants.NodePrivacyLevel.HIDDEN) {
    // Should never occur, but just in case, we set to CENSORED_MARK.
    textContent = _constants.CENSORED_STRING_MARK;
  } else if (shouldMaskNode(textNode, nodePrivacyLevel)) {
    if (
    // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP
    parentTagName === 'DATALIST' || parentTagName === 'SELECT' || parentTagName === 'OPTGROUP') {
      if (!textContent.trim()) {
        return;
      }
    } else if (parentTagName === 'OPTION') {
      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked
      textContent = _constants.CENSORED_STRING_MARK;
    } else {
      textContent = censorText(textContent);
    }
  }
  //   else if (isStyle && textContent) {
  //     try {
  //       // try to read style sheet
  //       if (textNode.nextSibling || textNode.previousSibling) {
  //         // This is not the only child of the stylesheet.
  //         // We can't read all of the sheet's .cssRules and expect them
  //         // to _only_ include the current rule(s) added by the text node.
  //         // So we'll be conservative and keep textContent as-is.
  //       } else if (
  //         textNode.parentNode &&
  //         textNode.parentNode.sheet &&
  //         textNode.parentNode.sheet.cssRules
  //       ) {
  //         textContent = getCssRulesString(textNode.parentNode.sheet)
  //       }
  //     } catch (err) {}
  //     textContent = switchToAbsoluteUrl(textContent, getHref())
  //   }
  return textContent;
}

/**
 * We don't need this logic on the recorder side.
 * For security related meta's, customer can mask themmanually given they
 * are easy to identify in the HEAD tag.
 */
function shouldIgnoreElement(element) {
  if (element.nodeName === 'SCRIPT') {
    return true;
  }
  if (element.nodeName === 'LINK') {
    var relAttribute = getLowerCaseAttribute('rel');
    return (
      // Link as script - Ignore only when rel=preload, modulepreload or prefetch
      /preload|prefetch/i.test(relAttribute) && getLowerCaseAttribute('as') === 'script' ||
      // Favicons
      relAttribute === 'shortcut icon' || relAttribute === 'icon'
    );
  }
  if (element.nodeName === 'META') {
    var nameAttribute = getLowerCaseAttribute('name');
    var relAttribute = getLowerCaseAttribute('rel');
    var propertyAttribute = getLowerCaseAttribute('property');
    return (
      // Favicons
      /^msapplication-tile(image|color)$/.test(nameAttribute) || nameAttribute === 'application-name' || relAttribute === 'icon' || relAttribute === 'apple-touch-icon' || relAttribute === 'shortcut icon' ||
      // Description
      nameAttribute === 'keywords' || nameAttribute === 'description' ||
      // Social
      /^(og|twitter|fb):/.test(propertyAttribute) || /^(og|twitter):/.test(nameAttribute) || nameAttribute === 'pinterest' ||
      // Robots
      nameAttribute === 'robots' || nameAttribute === 'googlebot' || nameAttribute === 'bingbot' ||
      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,
      // X-Translated-By
      element.hasAttribute('http-equiv') ||
      // Authorship
      nameAttribute === 'author' || nameAttribute === 'generator' || nameAttribute === 'framework' || nameAttribute === 'publisher' || nameAttribute === 'progid' || /^article:/.test(propertyAttribute) || /^product:/.test(propertyAttribute) ||
      // Verification
      nameAttribute === 'google-site-verification' || nameAttribute === 'yandex-verification' || nameAttribute === 'csrf-token' || nameAttribute === 'p:domain_verify' || nameAttribute === 'verify-v1' || nameAttribute === 'verification' || nameAttribute === 'shopify-checkout-api-token'
    );
  }
  function getLowerCaseAttribute(name) {
    return (element.getAttribute(name) || '').toLowerCase();
  }
  return false;
}
//# sourceMappingURL=privacy.js.map