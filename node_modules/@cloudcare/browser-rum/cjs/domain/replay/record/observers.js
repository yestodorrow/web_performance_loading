"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRecordIdForEvent = getRecordIdForEvent;
exports.initFrustrationObserver = initFrustrationObserver;
exports.initInputObserver = initInputObserver;
exports.initMouseInteractionObserver = initMouseInteractionObserver;
exports.initMoveObserver = initMoveObserver;
exports.initMutationObserver = initMutationObserver;
exports.initObservers = initObservers;
exports.initStyleSheetObserver = initStyleSheetObserver;
var _browserCore = require("@cloudcare/browser-core");
var _initViewportObservable = require("../../initViewportObservable");
var _constants = require("../../../constants");
var _types = require("../../../types");
var _privacy = require("./privacy");
var _serializationUtils = require("./serializationUtils");
var _utils = require("./utils");
var _mutationObserver = require("./mutationObserver");
var _viewports = require("./viewports");
var _eventTypeToMouseInte;
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var MOUSE_MOVE_OBSERVER_THRESHOLD = 50;
var SCROLL_OBSERVER_THRESHOLD = 100;
var VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200;
var recordIds = new WeakMap();
var nextId = 1;
function getRecordIdForEvent(event) {
  if (!recordIds.has(event)) {
    recordIds.set(event, nextId++);
  }
  return recordIds.get(event);
}
function initObservers(o) {
  var mutationHandler = initMutationObserver(o.mutationCb, o.configuration, o.shadowRootsController);
  var mousemoveHandler = initMoveObserver(o.mousemoveCb);
  var mouseInteractionHandler = initMouseInteractionObserver(o.mouseInteractionCb, o.configuration.defaultPrivacyLevel);
  var scrollHandler = initScrollObserver(o.scrollCb, o.configuration.defaultPrivacyLevel, o.elementsScrollPositions);
  var viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);
  var inputHandler = initInputObserver(o.inputCb, o.configuration.defaultPrivacyLevel);
  var mediaInteractionHandler = initMediaInteractionObserver(o.mediaInteractionCb, o.configuration.defaultPrivacyLevel);
  var styleSheetObserver = initStyleSheetObserver(o.styleSheetCb);
  var focusHandler = initFocusObserver(o.focusCb);
  var visualViewportResizeHandler = initVisualViewportResizeObserver(o.visualViewportResizeCb);
  var frustrationHandler = initFrustrationObserver(o.lifeCycle, o.frustrationCb);
  return {
    flush: function flush() {
      mutationHandler.flush();
    },
    stop: function stop() {
      mutationHandler.stop();
      mousemoveHandler();
      mouseInteractionHandler();
      scrollHandler();
      viewportResizeHandler();
      inputHandler();
      mediaInteractionHandler();
      styleSheetObserver();
      focusHandler();
      visualViewportResizeHandler();
      frustrationHandler();
    }
  };
}
function initMutationObserver(cb, configuration, shadowRootsController) {
  return (0, _mutationObserver.startMutationObserver)(cb, configuration, shadowRootsController, document);
}
function initMoveObserver(cb) {
  var _updatePosition = (0, _browserCore.throttle)(function (event) {
    var target = getEventTarget(event);
    if ((0, _serializationUtils.hasSerializedNode)(target)) {
      var coordinates = tryToComputeCoordinates(event);
      if (!coordinates) {
        return;
      }
      var position = {
        id: (0, _serializationUtils.getSerializedNodeId)(target),
        timeOffset: 0,
        x: coordinates.x,
        y: coordinates.y
      };
      cb([position], (0, _utils.isTouchEvent)(event) ? _types.IncrementalSource.TouchMove : _types.IncrementalSource.MouseMove);
    }
  }, MOUSE_MOVE_OBSERVER_THRESHOLD, {
    trailing: false
  });
  var cancelThrottle = _updatePosition.cancel;
  var updatePosition = _updatePosition.throttled;
  var _listener = (0, _browserCore.addEventListeners)(document, [_browserCore.DOM_EVENT.MOUSE_MOVE, _browserCore.DOM_EVENT.TOUCH_MOVE], updatePosition, {
    capture: true,
    passive: true
  });
  var removeListener = _listener.stop;
  return function () {
    removeListener();
    cancelThrottle();
  };
}
var eventTypeToMouseInteraction = (_eventTypeToMouseInte = {}, _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.POINTER_UP, _types.MouseInteractionType.MouseUp), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.MOUSE_DOWN, _types.MouseInteractionType.MouseDown), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.CLICK, _types.MouseInteractionType.Click), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.CONTEXT_MENU, _types.MouseInteractionType.ContextMenu), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.DBL_CLICK, _types.MouseInteractionType.DblClick), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.FOCUS, _types.MouseInteractionType.Focus), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.BLUR, _types.MouseInteractionType.Blur), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.TOUCH_START, _types.MouseInteractionType.TouchStart), _defineProperty(_eventTypeToMouseInte, _browserCore.DOM_EVENT.TOUCH_END, _types.MouseInteractionType.TouchEnd), _eventTypeToMouseInte);
function initMouseInteractionObserver(cb, defaultPrivacyLevel) {
  var handler = function handler(event) {
    var target = getEventTarget(event);
    if ((0, _privacy.getNodePrivacyLevel)(target, defaultPrivacyLevel) === _constants.NodePrivacyLevel.HIDDEN || !(0, _serializationUtils.hasSerializedNode)(target)) {
      return;
    }
    var id = (0, _serializationUtils.getSerializedNodeId)(target);
    var type = eventTypeToMouseInteraction[event.type];
    var interaction;
    if (type !== _types.MouseInteractionType.Blur && type !== _types.MouseInteractionType.Focus) {
      var coordinates = tryToComputeCoordinates(event);
      if (!coordinates) {
        return;
      }
      interaction = {
        id: id,
        type: type,
        x: coordinates.x,
        y: coordinates.y
      };
    } else {
      interaction = {
        id: id,
        type: type
      };
    }
    var record = (0, _browserCore.assign)({
      id: getRecordIdForEvent(event)
    }, (0, _utils.assembleIncrementalSnapshot)(_types.IncrementalSource.MouseInteraction, interaction));
    cb(record);
  };
  return (0, _browserCore.addEventListeners)(document, Object.keys(eventTypeToMouseInteraction), handler, {
    capture: true,
    passive: true
  }).stop;
}
function tryToComputeCoordinates(event) {
  var _event = (0, _utils.isTouchEvent)(event) ? event.changedTouches[0] : event;
  var x = _event.clientX;
  var y = _event.clientY;
  if (window.visualViewport) {
    var _convertMouseEventToLayoutCoordinates = (0, _viewports.convertMouseEventToLayoutCoordinates)(x, y);
    x = _convertMouseEventToLayoutCoordinates.visualViewportX;
    y = _convertMouseEventToLayoutCoordinates.visualViewportY;
  }
  if (!Number.isFinite(x) || !Number.isFinite(y)) {
    return undefined;
  }
  return {
    x: x,
    y: y
  };
}
function initScrollObserver(cb, defaultPrivacyLevel, elementsScrollPositions) {
  var _updatePosition = (0, _browserCore.throttle)(function (event) {
    var target = getEventTarget(event);
    if (!target || (0, _privacy.getNodePrivacyLevel)(target, defaultPrivacyLevel) === _constants.NodePrivacyLevel.HIDDEN || !(0, _serializationUtils.hasSerializedNode)(target)) {
      return;
    }
    var id = (0, _serializationUtils.getSerializedNodeId)(target);
    var scrollPositions = target === document ? {
      scrollTop: (0, _browserCore.getScrollY)(),
      scrollLeft: (0, _browserCore.getScrollX)()
    } : {
      scrollTop: Math.round(target.scrollTop),
      scrollLeft: Math.round(target.scrollLeft)
    };
    elementsScrollPositions.set(target, scrollPositions);
    cb({
      id: id,
      x: scrollPositions.scrollLeft,
      y: scrollPositions.scrollTop
    });
  }, SCROLL_OBSERVER_THRESHOLD);
  var cancelThrottle = _updatePosition.cancel;
  var updatePosition = _updatePosition.throttled;
  var _listener = (0, _browserCore.addEventListener)(document, _browserCore.DOM_EVENT.SCROLL, updatePosition, {
    capture: true,
    passive: true
  });
  var removeListener = _listener.stop;
  return function () {
    removeListener();
    cancelThrottle();
  };
}
function initViewportResizeObserver(cb) {
  return (0, _initViewportObservable.initViewportObservable)().subscribe(cb).unsubscribe;
}
function initInputObserver(cb, defaultPrivacyLevel, target) {
  if (target === undefined) {
    target = document;
  }
  var lastInputStateMap = new WeakMap();
  var isShadowRoot = target !== document;
  var _addEventListeners = (0, _browserCore.addEventListeners)(target,
  // The 'input' event bubbles across shadow roots, so we don't have to listen for it on shadow
  // roots since it will be handled by the event listener that we did add to the document. Only
  // the 'change' event is blocked and needs to be handled on shadow roots.
  isShadowRoot ? [_browserCore.DOM_EVENT.CHANGE] : [_browserCore.DOM_EVENT.INPUT, _browserCore.DOM_EVENT.CHANGE], function (event) {
    var target = getEventTarget(event);
    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement) {
      onElementChange(target);
    }
  }, {
    capture: true,
    passive: true
  });
  var stopEventListeners = _addEventListeners.stop;
  var stopPropertySetterInstrumentation;
  if (!isShadowRoot) {
    var instrumentationStoppers = [(0, _browserCore.instrumentSetter)(HTMLInputElement.prototype, 'value', onElementChange), (0, _browserCore.instrumentSetter)(HTMLInputElement.prototype, 'checked', onElementChange), (0, _browserCore.instrumentSetter)(HTMLSelectElement.prototype, 'value', onElementChange), (0, _browserCore.instrumentSetter)(HTMLTextAreaElement.prototype, 'value', onElementChange), (0, _browserCore.instrumentSetter)(HTMLSelectElement.prototype, 'selectedIndex', onElementChange)];
    stopPropertySetterInstrumentation = function stopPropertySetterInstrumentation() {
      instrumentationStoppers.forEach(function (stopper) {
        return stopper.stop();
      });
    };
  } else {
    stopPropertySetterInstrumentation = _browserCore.noop;
  }
  return function () {
    stopPropertySetterInstrumentation();
    stopEventListeners();
  };
  function onElementChange(target) {
    var nodePrivacyLevel = (0, _privacy.getNodePrivacyLevel)(target, defaultPrivacyLevel);
    if (nodePrivacyLevel === _constants.NodePrivacyLevel.HIDDEN) {
      return;
    }
    var type = target.type;
    var inputState;
    if (type === 'radio' || type === 'checkbox') {
      if ((0, _privacy.shouldMaskNode)(target, nodePrivacyLevel)) {
        return;
      }
      inputState = {
        isChecked: target.checked
      };
    } else {
      var value = (0, _serializationUtils.getElementInputValue)(target, nodePrivacyLevel);
      if (value === undefined) {
        return;
      }
      inputState = {
        text: value
      };
    }

    // Can be multiple changes on the same node within the same batched mutation observation.
    cbWithDedup(target, inputState);

    // If a radio was checked, other radios with the same name attribute will be unchecked.
    var name = target.name;
    if (type === 'radio' && name && target.checked) {
      (0, _utils.forEach)(document.querySelectorAll('input[type="radio"][name="' + (0, _browserCore.cssEscape)(name) + '"]'), function (el) {
        if (el !== target) {
          cbWithDedup(el, {
            isChecked: false
          });
        }
      });
    }
  }

  /**
   * There can be multiple changes on the same node within the same batched mutation observation.
   */
  function cbWithDedup(target, inputState) {
    if (!(0, _serializationUtils.hasSerializedNode)(target)) {
      return;
    }
    var lastInputState = lastInputStateMap.get(target);
    if (!lastInputState || lastInputState.text !== inputState.text || lastInputState.isChecked !== inputState.isChecked) {
      lastInputStateMap.set(target, inputState);
      cb((0, _browserCore.assign)({
        id: (0, _serializationUtils.getSerializedNodeId)(target)
      }, inputState));
    }
  }
}
function initStyleSheetObserver(cb) {
  function checkStyleSheetAndCallback(styleSheet, callback) {
    if (styleSheet && (0, _serializationUtils.hasSerializedNode)(styleSheet.ownerNode)) {
      callback((0, _serializationUtils.getSerializedNodeId)(styleSheet.ownerNode));
    }
  }
  var instrumentationStoppers = [(0, _browserCore.instrumentMethodAndCallOriginal)(CSSStyleSheet.prototype, 'insertRule', {
    before: function before(rule, index) {
      checkStyleSheetAndCallback(this, function (id) {
        return cb({
          id: id,
          adds: [{
            rule: rule,
            index: index
          }]
        });
      });
    }
  }), (0, _browserCore.instrumentMethodAndCallOriginal)(CSSStyleSheet.prototype, 'deleteRule', {
    before: function before(index) {
      checkStyleSheetAndCallback(this, function (id) {
        return cb({
          id: id,
          removes: [{
            index: index
          }]
        });
      });
    }
  })];
  if (typeof CSSGroupingRule !== 'undefined') {
    instrumentGroupingCSSRuleClass(CSSGroupingRule);
  } else {
    instrumentGroupingCSSRuleClass(CSSMediaRule);
    instrumentGroupingCSSRuleClass(CSSSupportsRule);
  }
  function instrumentGroupingCSSRuleClass(cls) {
    instrumentationStoppers.push((0, _browserCore.instrumentMethodAndCallOriginal)(cls.prototype, 'insertRule', {
      before: function before(rule, index) {
        var _this = this;
        checkStyleSheetAndCallback(this.parentStyleSheet, function (id) {
          var path = (0, _utils.getPathToNestedCSSRule)(_this);
          if (path) {
            path.push(index || 0);
            cb({
              id: id,
              adds: [{
                rule: rule,
                index: path
              }]
            });
          }
        });
      }
    }), (0, _browserCore.instrumentMethodAndCallOriginal)(cls.prototype, 'deleteRule', {
      before: function before(index) {
        var _this = this;
        checkStyleSheetAndCallback(this.parentStyleSheet, function (id) {
          var path = (0, _utils.getPathToNestedCSSRule)(_this);
          if (path) {
            path.push(index);
            cb({
              id: id,
              removes: [{
                index: path
              }]
            });
          }
        });
      }
    }));
  }
  return function () {
    instrumentationStoppers.forEach(function (stopper) {
      stopper.stop();
    });
  };
}
function initMediaInteractionObserver(mediaInteractionCb, defaultPrivacyLevel) {
  var handler = function handler(event) {
    var target = getEventTarget(event);
    if (!target || (0, _privacy.getNodePrivacyLevel)(target, defaultPrivacyLevel) === _constants.NodePrivacyLevel.HIDDEN || !(0, _serializationUtils.hasSerializedNode)(target)) {
      return;
    }
    mediaInteractionCb({
      id: (0, _serializationUtils.getSerializedNodeId)(target),
      type: event.type === _browserCore.DOM_EVENT.PLAY ? _types.MediaInteractionType.Play : _types.MediaInteractionType.Pause
    });
  };
  return (0, _browserCore.addEventListeners)(document, [_browserCore.DOM_EVENT.PLAY, _browserCore.DOM_EVENT.PAUSE], handler, {
    capture: true,
    passive: true
  }).stop;
}
function initFocusObserver(focusCb) {
  return (0, _browserCore.addEventListeners)(window, [_browserCore.DOM_EVENT.FOCUS, _browserCore.DOM_EVENT.BLUR], function () {
    focusCb({
      has_focus: document.hasFocus()
    });
  }).stop;
}
function initVisualViewportResizeObserver(cb) {
  if (!window.visualViewport) {
    return _browserCore.noop;
  }
  var _updateDimension = (0, _browserCore.throttle)(function () {
    cb((0, _viewports.getVisualViewport)());
  }, VISUAL_VIEWPORT_OBSERVER_THRESHOLD, {
    trailing: false
  });
  var removeListener = (0, _browserCore.addEventListeners)(window.visualViewport, [_browserCore.DOM_EVENT.RESIZE, _browserCore.DOM_EVENT.SCROLL], _updateDimension.throttled, {
    capture: true,
    passive: true
  }).stop;
  var cancelThrottle = _updateDimension.cancel;
  return function stop() {
    removeListener();
    cancelThrottle();
  };
}
function initFrustrationObserver(lifeCycle, frustrationCb) {
  return lifeCycle.subscribe(_browserCore.LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, function (data) {
    if (data.rawRumEvent.type === _browserCore.RumEventType.ACTION && data.rawRumEvent.action.type === _browserCore.ActionType.CLICK && data.rawRumEvent.action.frustration && data.rawRumEvent.action.frustration.type && data.rawRumEvent.action.frustration.type.length && 'events' in data.domainContext && data.domainContext.events && data.domainContext.events.length) {
      frustrationCb({
        timestamp: data.rawRumEvent.date,
        type: _types.RecordType.FrustrationRecord,
        data: {
          frustrationTypes: data.rawRumEvent.action.frustration.type,
          recordIds: data.domainContext.events.map(function (e) {
            return getRecordIdForEvent(e);
          })
        }
      });
    }
  }).unsubscribe;
}
function getEventTarget(event) {
  if (event.composed === true && (0, _browserCore.isNodeShadowHost)(event.target)) {
    return event.composedPath()[0];
  }
  return event.target;
}
//# sourceMappingURL=observers.js.map