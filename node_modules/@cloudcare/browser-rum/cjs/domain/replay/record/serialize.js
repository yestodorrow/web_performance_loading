"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SerializationContextStatus = void 0;
exports.serializeAttribute = serializeAttribute;
exports.serializeChildNodes = serializeChildNodes;
exports.serializeDocument = serializeDocument;
exports.serializeDocumentNode = serializeDocumentNode;
exports.serializeElementNode = serializeElementNode;
exports.serializeNodeWithId = serializeNodeWithId;
var _browserCore = require("@cloudcare/browser-core");
var _getSelectorsFromElement = require("../../rumEventsCollection/actions/getSelectorsFromElement");
var _constants = require("../../../constants");
var _types = require("../../../types");
var _privacy = require("./privacy");
var _serializationUtils = require("./serializationUtils");
var _resourceUtils = require("../../rumEventsCollection/resource/resourceUtils");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Those values are the only one that can be used when inheriting privacy levels from parent to
// children during serialization, since HIDDEN and IGNORE shouldn't serialize their children. This
// ensures that no children are serialized when they shouldn't.

var SerializationContextStatus = {
  INITIAL_FULL_SNAPSHOT: 0,
  SUBSEQUENT_FULL_SNAPSHOT: 1,
  MUTATION: 2
};
exports.SerializationContextStatus = SerializationContextStatus;
function serializeDocument(document, configuration, serializationContext) {
  // We are sure that Documents are never ignored, so this function never returns null
  return serializeNodeWithId(document, {
    serializationContext: serializationContext,
    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,
    configuration: configuration
  });
}
function serializeNodeWithId(node, options) {
  var serializedNode = serializeNode(node, options);
  if (!serializedNode) {
    return null;
  }

  // Try to reuse the previous id
  var id = (0, _serializationUtils.getSerializedNodeId)(node) || generateNextId();
  var serializedNodeWithId = serializedNode;
  serializedNodeWithId.id = id;
  (0, _serializationUtils.setSerializedNodeId)(node, id);
  if (options.serializedNodeIds) {
    options.serializedNodeIds.add(id);
  }
  return serializedNodeWithId;
}
function serializeNode(node, options) {
  switch (node.nodeType) {
    case node.DOCUMENT_NODE:
      return serializeDocumentNode(node, options);
    case node.DOCUMENT_FRAGMENT_NODE:
      return serializeDocumentFragmentNode(node, options);
    case node.DOCUMENT_TYPE_NODE:
      return serializeDocumentTypeNode(node);
    case node.ELEMENT_NODE:
      return serializeElementNode(node, options);
    case node.TEXT_NODE:
      return serializeTextNode(node, options);
    case node.CDATA_SECTION_NODE:
      return serializeCDataNode();
  }
}
function serializeDocumentNode(document, options) {
  return {
    type: _types.NodeType.Document,
    childNodes: serializeChildNodes(document, options),
    adoptedStyleSheets: (0, _serializationUtils.serializeStyleSheets)(document.adoptedStyleSheets)
  };
}
function serializeDocumentTypeNode(documentType) {
  return {
    type: _types.NodeType.DocumentType,
    name: documentType.name,
    publicId: documentType.publicId,
    systemId: documentType.systemId
  };
}
function serializeDocumentFragmentNode(element, options) {
  var isShadowRoot = (0, _browserCore.isNodeShadowRoot)(element);
  if (isShadowRoot) {
    options.serializationContext.shadowRootsController.addShadowRoot(element);
  }
  return {
    type: _types.NodeType.DocumentFragment,
    childNodes: serializeChildNodes(element, options),
    isShadowRoot: isShadowRoot,
    adoptedStyleSheets: isShadowRoot ? (0, _serializationUtils.serializeStyleSheets)(element.adoptedStyleSheets) : undefined
  };
}

/**
 * Serializing Element nodes involves capturing:
 * 1. HTML ATTRIBUTES:
 * 2. JS STATE:
 * - scroll offsets
 * - Form fields (input value, checkbox checked, option selection, range)
 * - Canvas state,
 * - Media (video/audio) play mode + currentTime
 * - iframe contents
 * - webcomponents
 * 3. CUSTOM PROPERTIES:
 * - height+width for when `hidden` to cover the element
 * 4. EXCLUDED INTERACTION STATE:
 * - focus (possible, but not worth perf impact)
 * - hover (tracked only via mouse activity)
 * - fullscreen mode
 */
function serializeElementNode(element, options) {
  var tagName = getValidTagName(element.tagName);
  var isSVG = (0, _serializationUtils.isSVGElement)(element) || undefined;

  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the
  // parentNodePrivacyLevel option to avoid iterating over all parents
  var nodePrivacyLevel = (0, _privacy.reducePrivacyLevel)((0, _privacy.getNodeSelfPrivacyLevel)(element), options.parentNodePrivacyLevel);
  if (nodePrivacyLevel === _constants.NodePrivacyLevel.HIDDEN) {
    var _boundingClientRect = element.getBoundingClientRect();
    var width = _boundingClientRect.width;
    var height = _boundingClientRect.height;
    return {
      type: _types.NodeType.Element,
      tagName: tagName,
      attributes: _defineProperty({
        rr_width: width + 'px',
        rr_height: height + 'px'
      }, _constants.PRIVACY_ATTR_NAME, _constants.PRIVACY_ATTR_VALUE_HIDDEN),
      childNodes: [],
      isSVG: isSVG
    };
  }

  // Ignore Elements like Script and some Link, Metas
  if (nodePrivacyLevel === _constants.NodePrivacyLevel.IGNORE) {
    return;
  }
  var attributes = getAttributesForPrivacyLevel(element, nodePrivacyLevel, options);
  var childNodes = [];
  if ((0, _browserCore.hasChildNodes)(element) && tagName !== 'style') {
    // OBJECT POOLING OPTIMIZATION:
    // We should not create a new object systematically as it could impact performances. Try to reuse
    // the same object as much as possible, and clone it only if we need to.
    var childNodesSerializationOptions;
    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {
      childNodesSerializationOptions = options;
    } else {
      childNodesSerializationOptions = (0, _browserCore.assign)({}, options, {
        parentNodePrivacyLevel: nodePrivacyLevel,
        ignoreWhiteSpace: tagName === 'head'
      });
    }
    childNodes = serializeChildNodes(element, childNodesSerializationOptions);
  }

  //   if (isNodeShadowHost(element)) {
  //     var shadowRoot = serializeNodeWithId(element.shadowRoot, options)
  //     if (shadowRoot !== null) {
  //       childNodes.push(shadowRoot)
  //     }
  //   }

  return {
    type: _types.NodeType.Element,
    tagName: tagName,
    attributes: attributes,
    childNodes: childNodes,
    isSVG: isSVG
  };
}

/**
 * Text Nodes are dependant on Element nodes
 * Privacy levels are set on elements so we check the parentElement of a text node
 * for privacy level.
 */
function serializeTextNode(textNode, options) {
  // The parent node may not be a html element which has a tagName attribute.
  // So just let it be undefined which is ok in this use case.
  //   var parentTagName = textNode.parentElement && textNode.parentElement.tagName
  var textContent = (0, _privacy.getTextContent)(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel);
  if (textContent === undefined) {
    return;
  }
  return {
    type: _types.NodeType.Text,
    textContent: textContent
    // isStyle: parentTagName === 'STYLE' ? true : undefined
  };
}

function serializeCDataNode() {
  return {
    type: _types.NodeType.CDATA,
    textContent: ''
  };
}
function serializeChildNodes(node, options) {
  var result = [];
  (0, _browserCore.forEachChildNodes)(node, function (childNode) {
    var serializedChildNode = serializeNodeWithId(childNode, options);
    if (serializedChildNode) {
      result.push(serializedChildNode);
    }
  });
  //   node.childNodes.forEach()
  return result;
}
function serializeAttribute(element, nodePrivacyLevel, attributeName, configuration) {
  if (nodePrivacyLevel === _constants.NodePrivacyLevel.HIDDEN) {
    // dup condition for direct access case
    return null;
  }
  var attributeValue = element.getAttribute(attributeName);
  if (nodePrivacyLevel === _constants.NodePrivacyLevel.MASK && attributeName !== _constants.PRIVACY_ATTR_NAME && !_getSelectorsFromElement.STABLE_ATTRIBUTES.includes(attributeName) && attributeName !== configuration.actionNameAttribute) {
    var tagName = element.tagName;
    switch (attributeName) {
      // Mask Attribute text content
      case 'title':
      case 'alt':
      case 'placeholder':
        return _constants.CENSORED_STRING_MARK;
    }
    // mask image URLs
    if (tagName === 'IMG' || tagName === 'SOURCE') {
      if (attributeName === 'src' || attributeName === 'srcset') {
        return _constants.CENSORED_IMG_MARK;
      } else if (attributeName === 'onerror') {
        return null;
      }
    }
    // mask <a> URLs
    if (tagName === 'A' && attributeName === 'href') {
      return _constants.CENSORED_STRING_MARK;
    }

    // mask data-* attributes
    if (attributeValue && (0, _browserCore.startsWith)(attributeName, 'data-')) {
      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr
      return _constants.CENSORED_STRING_MARK;
    }
    // mask iframe srcdoc
    if (tagName === 'IFRAME' && attributeName === 'srcdoc') {
      return _constants.CENSORED_STRING_MARK;
    }
  }
  if (!attributeValue || typeof attributeValue !== 'string') {
    return attributeValue;
  }

  // Minimum Fix for customer.
  //   if (
  //     attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH &&
  //     attributeValue.slice(0, 5) === 'data:'
  //   ) {
  //     return 'data:truncated'
  //   }
  if ((0, _resourceUtils.isLongDataUrl)(attributeValue)) {
    return (0, _resourceUtils.sanitizeDataUrl)(attributeValue);
  }
  return attributeValue;
}
var _nextId = 1;
function generateNextId() {
  return _nextId++;
}
var TAG_NAME_REGEX = /[^a-z1-6-_]/;
function getValidTagName(tagName) {
  var processedTagName = (tagName + '').toLowerCase().trim();
  if (TAG_NAME_REGEX.test(processedTagName)) {
    // if the tag name is odd and we cannot extract
    // anything from the string, then we return a
    // generic div
    return 'div';
  }
  return processedTagName;
}
function transformAttribute(doc, tagName, name, value) {
  if (!value) return value;
  if (name === 'src' || name === 'href' && !(tagName === 'use' && value[0] === '#')) {
    return (0, _serializationUtils.absoluteToDoc)(doc, value);
  } else if (name === 'xlink:href' && value[0] !== '#') {
    return (0, _serializationUtils.absoluteToDoc)(doc, value);
  } else if (name === 'background' && value && (tagName === 'table' || tagName === 'td' || tagName === 'th')) {
    return (0, _serializationUtils.absoluteToDoc)(doc, value);
  } else if (name === 'srcset') {
    return (0, _serializationUtils.getAbsoluteSrcsetString)(doc, value);
  } else if (name === 'style') {
    return (0, _serializationUtils.switchToAbsoluteUrl)(value, (0, _serializationUtils.getHref)());
  } else if (tagName === 'object' && name === 'data') {
    return (0, _serializationUtils.absoluteToDoc)(doc, value);
  } else {
    return value;
  }
}
function getAttributesForPrivacyLevel(element, nodePrivacyLevel, options) {
  if (nodePrivacyLevel === _constants.NodePrivacyLevel.HIDDEN) {
    return {};
  }
  var safeAttrs = {};
  var tagName = getValidTagName(element.tagName);
  var doc = element.ownerDocument;
  for (var i = 0; i < element.attributes.length; i += 1) {
    var attribute = element.attributes.item(i);
    var attributeName = attribute.name;
    var attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration);
    if (attributeValue !== null) {
      safeAttrs[attributeName] = transformAttribute(doc, tagName, attributeName, attributeValue);
    }
  }
  if (element.value && (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')) {
    var formValue = (0, _serializationUtils.getElementInputValue)(element, nodePrivacyLevel);
    if (formValue !== undefined) {
      safeAttrs.value = formValue;
    }
  }

  /**
   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`
   */
  if (tagName === 'option' && nodePrivacyLevel === _constants.NodePrivacyLevel.ALLOW) {
    // For privacy=`MASK`, all the values would be the same, so skip.
    var optionElement = element;
    if (optionElement.selected) {
      safeAttrs.selected = optionElement.selected;
    }
  }

  // remote css
  if (tagName === 'link') {
    var stylesheet = Array.from(doc.styleSheets).find(function (s) {
      return s.href === element.href;
    });
    var cssText = (0, _serializationUtils.getCssRulesString)(stylesheet);
    if (cssText && stylesheet) {
      safeAttrs._cssText = cssText;
    }
  }

  // dynamic stylesheet
  if (tagName === 'style' && element.sheet) {
    var cssText = (0, _serializationUtils.getCssRulesString)(element.sheet);
    if (cssText) {
      safeAttrs._cssText = cssText;
    }
  }

  /**
   * Forms: input[type=checkbox,radio]
   * The `checked` property for <input> is a little bit special:
   * 1. el.checked is a setter that returns if truthy.
   * 2. getAttribute returns the string value
   * getAttribute('checked') does not sync with `Element.checked`, so use JS property
   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.
   */
  var inputElement = element;
  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {
    if (nodePrivacyLevel === _constants.NodePrivacyLevel.ALLOW) {
      safeAttrs.checked = !!inputElement.checked;
    } else if ((0, _privacy.shouldMaskNode)(inputElement, nodePrivacyLevel)) {
      delete safeAttrs.checked;
    }
  }

  /**
   * Serialize the media playback state
   */
  if (tagName === 'audio' || tagName === 'video') {
    var mediaElement = element;
    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played';
  }

  /**
   * Serialize the scroll state for each element only for full snapshot
   */
  var scrollTop;
  var scrollLeft;
  var serializationContext = options.serializationContext;
  switch (serializationContext.status) {
    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:
      scrollTop = Math.round(element.scrollTop);
      scrollLeft = Math.round(element.scrollLeft);
      if (scrollTop || scrollLeft) {
        serializationContext.elementsScrollPositions.set(element, {
          scrollTop: scrollTop,
          scrollLeft: scrollLeft
        });
      }
      break;
    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:
      if (serializationContext.elementsScrollPositions.has(element)) {
        var scroll = serializationContext.elementsScrollPositions.get(element);
        scrollTop = scroll.scrollTop;
        scrollLeft = scroll.scrollLeft;
      }
      break;
  }
  if (scrollLeft) {
    safeAttrs.rr_scrollLeft = scrollLeft;
  }
  if (scrollTop) {
    safeAttrs.rr_scrollTop = scrollTop;
  }
  return safeAttrs;
}
//# sourceMappingURL=serialize.js.map