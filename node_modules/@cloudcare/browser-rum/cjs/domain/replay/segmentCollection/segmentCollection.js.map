{"version":3,"file":"segmentCollection.js","names":["_browserCore","require","_buildReplayPayload","_segment","SEGMENT_DURATION_LIMIT","ONE_SECOND","exports","SEGMENT_BYTES_LIMIT","startSegmentCollection","lifeCycle","configuration","sessionManager","viewContexts","httpRequest","encoder","doStartSegmentCollection","computeSegmentContext","SegmentCollectionStatus","WaitingForInitialRecord","SegmentPending","Stopped","getSegmentContext","state","status","nextSegmentCreationReason","subscribeViewCreated","subscribe","LifeCycleEventType","VIEW_CREATED","flushSegment","unsubscribeViewCreated","unsubscribe","subscribePageExited","PAGE_EXITED","pageExitEvent","reason","unsubscribePageExited","flushReason","segment","flush","metadata","payload","buildReplayPayload","getEncodedBytes","getRawBytesCount","isPageExitReason","sendOnExit","send","clearTimeout","expirationTimeoutId","addRecord","record","context","Segment","setTimeout","getEncodedBytesCount","stop","session","findTrackedSession","viewContext","findView","undefined","sdk","name","sdkName","version","sdkVersion","env","service","app","id","applicationId","view","setSegmentBytesLimit","newSegmentBytesLimit","arguments","length"],"sources":["../../../../src/domain/replay/segmentCollection/segmentCollection.js"],"sourcesContent":["import {\n  ONE_SECOND,\n  LifeCycleEventType,\n  isPageExitReason,\n  setTimeout,\n  clearTimeout\n} from '@cloudcare/browser-core'\nimport { buildReplayPayload } from './buildReplayPayload'\nimport { Segment } from './segment'\n\nexport var SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport var SEGMENT_BYTES_LIMIT = 60000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle,\n  configuration,\n  sessionManager,\n  viewContexts,\n  httpRequest,\n  encoder\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    function () {\n      return computeSegmentContext(configuration, sessionManager, viewContexts)\n    },\n    httpRequest,\n    encoder\n  )\n}\n\nvar SegmentCollectionStatus = {\n  WaitingForInitialRecord: 0,\n  SegmentPending: 1,\n  Stopped: 2\n}\n\nexport function doStartSegmentCollection(\n  lifeCycle,\n  getSegmentContext,\n  httpRequest,\n  encoder\n) {\n  var state = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init'\n  }\n  var subscribeViewCreated = lifeCycle.subscribe(\n    LifeCycleEventType.VIEW_CREATED,\n    function () {\n      flushSegment('view_change')\n    }\n  )\n  var unsubscribeViewCreated = subscribeViewCreated.unsubscribe\n  var subscribePageExited = lifeCycle.subscribe(\n    LifeCycleEventType.PAGE_EXITED,\n    function (pageExitEvent) {\n      flushSegment(pageExitEvent.reason)\n    }\n  )\n  var unsubscribePageExited = subscribePageExited.unsubscribe\n\n  function flushSegment(flushReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush(function (metadata) {\n        var payload = buildReplayPayload(\n          encoder.getEncodedBytes(),\n          metadata,\n          encoder.getRawBytesCount()\n        )\n\n        if (isPageExitReason(flushReason)) {\n          httpRequest.sendOnExit(payload)\n        } else {\n          httpRequest.send(payload)\n        }\n      })\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (flushReason !== 'stop') {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason: flushReason\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped\n      }\n    }\n  }\n\n  return {\n    addRecord: function (record) {\n      if (state.status === SegmentCollectionStatus.Stopped) {\n        return\n      }\n\n      if (state.status === SegmentCollectionStatus.WaitingForInitialRecord) {\n        var context = getSegmentContext()\n        if (!context) {\n          return\n        }\n\n        state = {\n          status: SegmentCollectionStatus.SegmentPending,\n          segment: new Segment(\n            encoder,\n            context,\n            state.nextSegmentCreationReason\n          ),\n          expirationTimeoutId: setTimeout(function () {\n            flushSegment('segment_duration_limit')\n          }, SEGMENT_DURATION_LIMIT)\n        }\n      }\n\n      var segment = state.segment\n\n      segment.addRecord(record, function () {\n        if (\n          // the written segment is still pending\n          state.status === SegmentCollectionStatus.SegmentPending &&\n          state.segment === segment &&\n          encoder.getEncodedBytesCount() > SEGMENT_BYTES_LIMIT\n        ) {\n          flushSegment('segment_bytes_limit')\n        }\n      })\n    },\n\n    stop: function () {\n      flushSegment('stop')\n      unsubscribeViewCreated()\n      unsubscribePageExited()\n    }\n  }\n}\n\nexport function computeSegmentContext(\n  configuration,\n  sessionManager,\n  viewContexts\n) {\n  var session = sessionManager.findTrackedSession()\n  var viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    sdk: {\n      name: configuration.sdkName,\n      version: configuration.sdkVersion\n    },\n    env: configuration.env || '',\n    service: viewContext.service || configuration.service || 'browser',\n    version: viewContext.version || configuration.version || '',\n    app: {\n      id: configuration.applicationId\n    },\n    session: {\n      id: session.id\n    },\n    view: {\n      id: viewContext.id\n    }\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n"],"mappings":"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","ignoreList":[]}