"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHttpRequest = createHttpRequest;
exports.fetchKeepAliveStrategy = fetchKeepAliveStrategy;
var _sendWithRetryStrategy = require("./sendWithRetryStrategy");
var _addEventListener = require("../browser/addEventListener");
var _monitor = require("../helper/monitor");
/**
 * Use POST request without content type to:
 * - avoid CORS preflight requests
 * - allow usage of sendBeacon
 *
 * multiple elements are sent separated by \n in order
 * to be parsed correctly without content type header
 */
function addBatchPrecision(url) {
  if (!url) return url;
  return url + (url.indexOf('?') === -1 ? '?' : '&') + 'precision=ms';
}
function createHttpRequest(endpointUrl, bytesLimit, sendContentTypeByJson, reportError) {
  var contentType = sendContentTypeByJson ? 'application/json; charset=UTF-8' : undefined;
  var retryState = (0, _sendWithRetryStrategy.newRetryState)();
  var sendStrategyForRetry = function sendStrategyForRetry(payload, onResponse) {
    return fetchKeepAliveStrategy(endpointUrl, bytesLimit, contentType, payload, onResponse);
  };
  return {
    send: function send(payload) {
      (0, _sendWithRetryStrategy.sendWithRetryStrategy)(payload, retryState, sendStrategyForRetry, endpointUrl, reportError);
    },
    /**
     * Since fetch keepalive behaves like regular fetch on Firefox,
     * keep using sendBeaconStrategy on exit
     */
    sendOnExit: function sendOnExit(payload) {
      sendBeaconStrategy(endpointUrl, bytesLimit, contentType, payload);
    }
  };
}
function sendBeaconStrategy(endpointUrl, bytesLimit, contentType, payload) {
  var data = payload.data;
  var bytesCount = payload.bytesCount;
  var url = addBatchPrecision(endpointUrl);
  var canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit;
  if (canUseBeacon) {
    try {
      var beaconData;
      if (contentType) {
        beaconData = new Blob([data], {
          type: contentType
        });
      } else {
        beaconData = data;
      }
      var isQueued = navigator.sendBeacon(url, beaconData);
      if (isQueued) {
        return;
      }
    } catch (e) {
      // reportBeaconError(e)
    }
  }
  sendXHR(url, contentType, data);
}
function fetchKeepAliveStrategy(endpointUrl, bytesLimit, contentType, payload, onResponse) {
  var data = payload.data;
  var bytesCount = payload.bytesCount;
  var url = addBatchPrecision(endpointUrl);
  var canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit;
  if (canUseKeepAlive) {
    var fetchOption = {
      method: 'POST',
      body: data,
      keepalive: true,
      mode: 'cors'
    };
    if (contentType) {
      fetchOption.headers = {
        'Content-Type': contentType
      };
    }
    fetch(url, fetchOption).then((0, _monitor.monitor)(function (response) {
      if (typeof onResponse === 'function') {
        onResponse({
          status: response.status,
          type: response.type
        });
      }
    }), (0, _monitor.monitor)(function () {
      // failed to queue the request
      sendXHR(url, contentType, data, onResponse);
    }));
  } else {
    sendXHR(url, contentType, data, onResponse);
  }
}
function isKeepAliveSupported() {
  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors
  try {
    return window.Request && 'keepalive' in new Request('http://a');
  } catch (_unused) {
    return false;
  }
}
function sendXHR(url, contentType, data, onResponse) {
  var request = new XMLHttpRequest();
  request.open('POST', url, true);
  if (contentType) {
    //application/json; charset=UTF-8
    request.setRequestHeader('Content-Type', contentType);
  }
  (0, _addEventListener.addEventListener)(request, 'loadend', function () {
    if (typeof onResponse === 'function') {
      onResponse({
        status: request.status
      });
    }
  }, {
    once: true
  });
  request.send(data);
}
//# sourceMappingURL=httpRequest.js.map