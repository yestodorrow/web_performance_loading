"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_QUEUE_BYTES_COUNT = exports.MAX_ONGOING_REQUESTS = exports.MAX_ONGOING_BYTES_COUNT = exports.MAX_BACKOFF_TIME = exports.INITIAL_BACKOFF_TIME = void 0;
exports.newRetryState = newRetryState;
exports.sendWithRetryStrategy = sendWithRetryStrategy;
var _tools = require("../helper/tools");
var _byteUtils = require("../helper/byteUtils");
var _errorTools = require("../helper/errorTools");
var _timer = require("../helper/timer");
var MAX_ONGOING_BYTES_COUNT = 80 * _byteUtils.ONE_KIBI_BYTE;
exports.MAX_ONGOING_BYTES_COUNT = MAX_ONGOING_BYTES_COUNT;
var MAX_ONGOING_REQUESTS = 32;
exports.MAX_ONGOING_REQUESTS = MAX_ONGOING_REQUESTS;
var MAX_QUEUE_BYTES_COUNT = 3 * _byteUtils.ONE_MEBI_BYTE;
exports.MAX_QUEUE_BYTES_COUNT = MAX_QUEUE_BYTES_COUNT;
var MAX_BACKOFF_TIME = 256 * _tools.ONE_SECOND;
exports.MAX_BACKOFF_TIME = MAX_BACKOFF_TIME;
var INITIAL_BACKOFF_TIME = _tools.ONE_SECOND;
exports.INITIAL_BACKOFF_TIME = INITIAL_BACKOFF_TIME;
var TransportStatus = {
  UP: 0,
  FAILURE_DETECTED: 1,
  DOWN: 2
};
var RetryReason = {
  AFTER_SUCCESS: 0,
  AFTER_RESUME: 1
};
function sendWithRetryStrategy(payload, state, sendStrategy, endpointUrl, reportError) {
  if (state.transportStatus === TransportStatus.UP && state.queuedPayloads.size() === 0 && state.bandwidthMonitor.canHandle(payload)) {
    send(payload, state, sendStrategy, {
      onSuccess: function onSuccess() {
        return retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointUrl, reportError);
      },
      onFailure: function onFailure() {
        state.queuedPayloads.enqueue(payload);
        scheduleRetry(state, sendStrategy, endpointUrl, reportError);
      }
    });
  } else {
    state.queuedPayloads.enqueue(payload);
  }
}
function scheduleRetry(state, sendStrategy, endpointUrl, reportError) {
  if (state.transportStatus !== TransportStatus.DOWN) {
    return;
  }
  (0, _timer.setTimeout)(function () {
    var payload = state.queuedPayloads.first();
    send(payload, state, sendStrategy, {
      onSuccess: function onSuccess() {
        state.queuedPayloads.dequeue();
        state.currentBackoffTime = INITIAL_BACKOFF_TIME;
        retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointUrl, reportError);
      },
      onFailure: function onFailure() {
        state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);
        scheduleRetry(state, sendStrategy, endpointUrl, reportError);
      }
    });
  }, state.currentBackoffTime);
}
function send(payload, state, sendStrategy, responseData) {
  var onSuccess = responseData.onSuccess;
  var onFailure = responseData.onFailure;
  state.bandwidthMonitor.add(payload);
  sendStrategy(payload, function (response) {
    state.bandwidthMonitor.remove(payload);
    if (!shouldRetryRequest(response)) {
      state.transportStatus = TransportStatus.UP;
      onSuccess();
    } else {
      // do not consider transport down if another ongoing request could succeed
      state.transportStatus = state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN;
      state.lastFailureStatus = response.status;
      onFailure();
    }
  });
}
function retryQueuedPayloads(reason, state, sendStrategy, endpointUrl, reportError) {
  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {
    reportError({
      message: 'Reached max ' + endpointUrl + ' events size queued for upload: ' + MAX_QUEUE_BYTES_COUNT / _byteUtils.ONE_MEBI_BYTE + 'MiB',
      source: _errorTools.ErrorSource.AGENT,
      startClocks: (0, _tools.clocksNow)()
    });
    state.queueFullReported = true;
  }
  var previousQueue = state.queuedPayloads;
  state.queuedPayloads = newPayloadQueue();
  while (previousQueue.size() > 0) {
    sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, endpointUrl, reportError);
  }
}
function shouldRetryRequest(response) {
  return response.type !== 'opaque' && (response.status === 0 && !navigator.onLine || response.status === 408 || response.status === 429 || response.status >= 500);
}
function newRetryState() {
  return {
    transportStatus: TransportStatus.UP,
    lastFailureStatus: 0,
    currentBackoffTime: INITIAL_BACKOFF_TIME,
    bandwidthMonitor: newBandwidthMonitor(),
    queuedPayloads: newPayloadQueue(),
    queueFullReported: false
  };
}
function newPayloadQueue() {
  var queue = [];
  return {
    bytesCount: 0,
    enqueue: function enqueue(payload) {
      if (this.isFull()) {
        return;
      }
      queue.push(payload);
      this.bytesCount += payload.bytesCount;
    },
    first: function first() {
      return queue[0];
    },
    dequeue: function dequeue() {
      var payload = queue.shift();
      if (payload) {
        this.bytesCount -= payload.bytesCount;
      }
      return payload;
    },
    size: function size() {
      return queue.length;
    },
    isFull: function isFull() {
      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;
    }
  };
}
function newBandwidthMonitor() {
  return {
    ongoingRequestCount: 0,
    ongoingByteCount: 0,
    canHandle: function canHandle(payload) {
      return this.ongoingRequestCount === 0 || this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT && this.ongoingRequestCount < MAX_ONGOING_REQUESTS;
    },
    add: function add(payload) {
      this.ongoingRequestCount += 1;
      this.ongoingByteCount += payload.bytesCount;
    },
    remove: function remove(payload) {
      this.ongoingRequestCount -= 1;
      this.ongoingByteCount -= payload.bytesCount;
    }
  };
}
//# sourceMappingURL=sendWithRetryStrategy.js.map