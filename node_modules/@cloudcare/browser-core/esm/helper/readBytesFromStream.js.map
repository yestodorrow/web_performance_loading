{"version":3,"file":"readBytesFromStream.js","names":["noop","each","monitor","readBytesFromStream","stream","callback","options","reader","getReader","chunks","readBytesCount","readMore","read","then","result","done","onDone","collectStreamBody","push","value","length","bytesLimit","error","cancel","bytes","limitExceeded","completeBuffer","Uint8Array","offset","chunk","set","slice","undefined"],"sources":["../../src/helper/readBytesFromStream.js"],"sourcesContent":["import { noop, each } from './tools'\nimport { monitor } from './monitor'\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nexport function readBytesFromStream(stream, callback, options) {\n  var reader = stream.getReader()\n  var chunks = []\n  var readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor(function (result) {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        if (options.collectStreamBody) {\n          chunks.push(result.value)\n        }\n        readBytesCount += result.value.length\n\n        if (readBytesCount > options.bytesLimit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor(function (error) {\n        callback(error)\n      })\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    var bytes\n    var limitExceeded\n    if (options.collectStreamBody) {\n      var completeBuffer\n      if (chunks.length === 1) {\n        // optimization: if the response is small enough to fit in a single buffer (provided by the browser), just\n        // use it directly.\n        completeBuffer = chunks[0]\n      } else {\n        // else, we need to copy buffers into a larger buffer to concatenate them.\n        completeBuffer = new Uint8Array(readBytesCount)\n        var offset = 0\n        each(chunks, function (chunk) {\n          completeBuffer.set(chunk, offset)\n          offset += chunk.length\n        })\n      }\n      bytes = completeBuffer.slice(0, options.bytesLimit)\n      limitExceeded = completeBuffer.length > options.bytesLimit\n    }\n    callback(undefined, bytes, limitExceeded)\n  }\n}\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,IAAI,QAAQ,SAAS;AACpC,SAASC,OAAO,QAAQ,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,mBAAmBA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EAC7D,IAAIC,MAAM,GAAGH,MAAM,CAACI,SAAS,CAAC,CAAC;EAC/B,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,cAAc,GAAG,CAAC;EAEtBC,QAAQ,CAAC,CAAC;EAEV,SAASA,QAAQA,CAAA,EAAG;IAClBJ,MAAM,CAACK,IAAI,CAAC,CAAC,CAACC,IAAI,CAChBX,OAAO,CAAC,UAAUY,MAAM,EAAE;MACxB,IAAIA,MAAM,CAACC,IAAI,EAAE;QACfC,MAAM,CAAC,CAAC;QACR;MACF;MAEA,IAAIV,OAAO,CAACW,iBAAiB,EAAE;QAC7BR,MAAM,CAACS,IAAI,CAACJ,MAAM,CAACK,KAAK,CAAC;MAC3B;MACAT,cAAc,IAAII,MAAM,CAACK,KAAK,CAACC,MAAM;MAErC,IAAIV,cAAc,GAAGJ,OAAO,CAACe,UAAU,EAAE;QACvCL,MAAM,CAAC,CAAC;MACV,CAAC,MAAM;QACLL,QAAQ,CAAC,CAAC;MACZ;IACF,CAAC,CAAC,EACFT,OAAO,CAAC,UAAUoB,KAAK,EAAE;MACvBjB,QAAQ,CAACiB,KAAK,CAAC;IACjB,CAAC,CACH,CAAC;EACH;EAEA,SAASN,MAAMA,CAAA,EAAG;IAChBT,MAAM,CAACgB,MAAM,CAAC,CAAC,SAAM;IACnB;IACA;IACAvB,IACF,CAAC;IAED,IAAIwB,KAAK;IACT,IAAIC,aAAa;IACjB,IAAInB,OAAO,CAACW,iBAAiB,EAAE;MAC7B,IAAIS,cAAc;MAClB,IAAIjB,MAAM,CAACW,MAAM,KAAK,CAAC,EAAE;QACvB;QACA;QACAM,cAAc,GAAGjB,MAAM,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM;QACL;QACAiB,cAAc,GAAG,IAAIC,UAAU,CAACjB,cAAc,CAAC;QAC/C,IAAIkB,MAAM,GAAG,CAAC;QACd3B,IAAI,CAACQ,MAAM,EAAE,UAAUoB,KAAK,EAAE;UAC5BH,cAAc,CAACI,GAAG,CAACD,KAAK,EAAED,MAAM,CAAC;UACjCA,MAAM,IAAIC,KAAK,CAACT,MAAM;QACxB,CAAC,CAAC;MACJ;MACAI,KAAK,GAAGE,cAAc,CAACK,KAAK,CAAC,CAAC,EAAEzB,OAAO,CAACe,UAAU,CAAC;MACnDI,aAAa,GAAGC,cAAc,CAACN,MAAM,GAAGd,OAAO,CAACe,UAAU;IAC5D;IACAhB,QAAQ,CAAC2B,SAAS,EAAER,KAAK,EAAEC,aAAa,CAAC;EAC3C;AACF","ignoreList":[]}